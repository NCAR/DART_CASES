! DART software - Copyright UCAR. This open source software is provided
! by UCAR, "as is", without charge, subject to all terms of use at
! http://www.image.ucar.edu/DAReS/DART/DART_download
!
! $Id$

!----------------------------------------------------------------------
! WARNING!!  The file obs_def_mod.f90 is AUTOGENERATED by the
! 'preprocess' program.  Any changes made to this file will be
! overwritten when it is regenerated.  To make permanent changes
! in the code, edit DEFAULT_obs_def_mod.F90, or edit the
! observation specific obs_def_xxx_mod.f90 files.
!----------------------------------------------------------------------

!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Any observation-specific modules which contain executable code to
! handle the interpolation and/or reading and writing of the obs will
! have the module code inserted here.  Then models only have to use
! the obs_def_mod module, and only include obs_def_mod.f90 in their
! path_names files.  To change the observation types/kinds, edit the
! model-specific 'input.nml' file and add or remove lines from the
! &preprocess_nml section, the 'input_files' list.
!
! Start of any user-defined executable module code
!----------------------------------------------------------------------

!---------------------------------------------------------------------------  
! Start of code inserted from ../../../observations/forward_operators/obs_def_gps_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_gps_mod

use        types_mod, only : r8, missing_r8, RAD2DEG, DEG2RAD, PI
use    utilities_mod, only : register_module, error_handler, E_ERR, &
                             nmlfileunit, check_namelist_read,      &
                             find_namelist_in_file, do_nml_file, do_nml_term, &
                             ascii_file_format
use     location_mod, only : location_type, set_location, get_location, &
                             is_vertical, &
                             VERTISHEIGHT
use  assim_model_mod, only : interpolate

use     obs_kind_mod, only : QTY_TEMPERATURE, QTY_SPECIFIC_HUMIDITY, &
                             QTY_PRESSURE

use  ensemble_manager_mod, only : ensemble_type
use obs_def_utilities_mod, only : track_status

implicit none
private

public :: set_gpsro_ref, get_gpsro_ref, write_gpsro_ref, read_gpsro_ref, &
          get_expected_gpsro_ref, interactive_gpsro_ref

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL$"
character(len=32 ), parameter :: revision = "$Revision$"
character(len=128), parameter :: revdate  = "$Date$"

logical, save :: module_initialized = .false.

! Storage for the special information required for GPS RO observations
!

! Because we are currently only generating one observation type
! (GPSRO_REFRACTIVITY), there must be enough of these to cover all gps
! obs in all obs_seq files that are read in (e.g. for obs_diag if you
! cover multiple days or weeks, you must have enough room for all of them.)
! the local operator needs none of this additional info; the best approach
! would be to keep a single QTY_GPSRO, but make 2 observation types.
! the local has no additional metadata; the nonlocal needs one of these
! allocated and filled in.
integer :: max_gpsro_obs = 100000
integer :: space_gpsro_obs

type gps_nonlocal_type
   private
   character(len=6) :: gpsro_ref_form
   real(r8)         :: ray_direction(3)
   real(r8)         :: rfict
   real(r8)         :: step_size
   real(r8)         :: ray_top
end type gps_nonlocal_type

type(gps_nonlocal_type), allocatable :: gps_data(:)

namelist /obs_def_gps_nml/ max_gpsro_obs

character(len=129) :: string1, string2
integer  :: ii
integer  :: keycount

contains

!------------------------------------------------------------------------------


  subroutine initialize_module
!------------------------------------------------------------------------------
!
! initialize global gps private key number and allocate space for obs data
integer :: rc, iunit


call register_module(source, revision, revdate)
module_initialized = .true.

! global count of all gps observations from any input file
keycount = 0

! Read the namelist entry
call find_namelist_in_file("input.nml", "obs_def_gps_nml", iunit)
read(iunit, nml = obs_def_gps_nml, iostat = rc)
call check_namelist_read(iunit, rc, "obs_def_gps_nml")

! Record the namelist values used for the run ...
if (do_nml_file()) write(nmlfileunit, nml=obs_def_gps_nml)
if (do_nml_term()) write(     *     , nml=obs_def_gps_nml)

! find max number of gps obs which can be stored, and initialize type
space_gpsro_obs = 2 * max_gpsro_obs
allocate(gps_data(space_gpsro_obs), stat = rc)
if (rc /= 0) then
   write(string1, *) 'initial allocation failed for gps observation data,', &
                       'itemcount = 2 x max_gpsro_obs = ', space_gpsro_obs
   call error_handler(E_ERR,'initialize_module', string1, &
                      source, revision, revdate)
endif

end subroutine initialize_module



 subroutine set_gpsro_ref(gpskey, nx, ny, nz, rfict0, ds, htop, subset0)
!------------------------------------------------------------------------------
!
! increment key and set all private data for this observation

integer,          intent(out) :: gpskey
real(r8),         intent(in)  :: nx, ny, nz, rfict0, ds, htop
character(len=6), intent(in)  :: subset0

if ( .not. module_initialized ) call initialize_module

keycount = keycount + 1
gpskey = keycount

if(gpskey > space_gpsro_obs) then
   write(string1, *) 'key (',gpskey,') exceeds 2 x max_gpsro_obs (',space_gpsro_obs,')'
   string2 = 'Increase max_gpsro_obs in input.nml &obs_def_gps_nml namelist.'
   call error_handler(E_ERR,'read_gpsro_ref', string1, &
                      source, revision, revdate, text2=string2)
endif

gps_data(gpskey)%ray_direction(1) = nx
gps_data(gpskey)%ray_direction(2) = ny
gps_data(gpskey)%ray_direction(3) = nz
gps_data(gpskey)%gpsro_ref_form   = subset0

gps_data(gpskey)%rfict     = rfict0
gps_data(gpskey)%step_size = ds
gps_data(gpskey)%ray_top   = htop

end subroutine set_gpsro_ref


 subroutine get_gpsro_ref(gpskey, nx, ny, nz, rfict0, ds, htop, subset0)
!------------------------------------------------------------------------------
!
! return all private data for this observation

integer,          intent(in)  :: gpskey
real(r8),         intent(out) :: nx, ny, nz, rfict0, ds, htop
character(len=6), intent(out) :: subset0

if ( .not. module_initialized ) call initialize_module

if (gpskey < 1 .or. gpskey > keycount) then
   write(string1, *) 'key (',gpskey,') out of valid range (1<=key<=',keycount,')'
   call error_handler(E_ERR,'get_gpsro_ref', string1, &
                      source, revision, revdate)
endif

nx = gps_data(gpskey)%ray_direction(1)
ny = gps_data(gpskey)%ray_direction(2)
nz = gps_data(gpskey)%ray_direction(3)
subset0 = gps_data(gpskey)%gpsro_ref_form

rfict0 = gps_data(gpskey)%rfict
ds     = gps_data(gpskey)%step_size
htop   = gps_data(gpskey)%ray_top

end subroutine get_gpsro_ref



 subroutine write_gpsro_ref(gpskey, ifile, fform)
!------------------------------------------------------------------------------
!

integer,          intent(in)           :: gpskey, ifile
character(len=*), intent(in), optional :: fform


if ( .not. module_initialized ) call initialize_module

! Write the 5 character identifier for verbose formatted output
! Write out the obs_def key for this observation
if (ascii_file_format(fform)) then
   write(ifile,11) gpskey
   write(ifile, *) gps_data(gpskey)%rfict, gps_data(gpskey)%step_size, &
                   gps_data(gpskey)%ray_top, &
                  (gps_data(gpskey)%ray_direction(ii), ii=1, 3), &
                   gps_data(gpskey)%gpsro_ref_form
11  format('gpsroref', i8)
else
   write(ifile) gpskey
   write(ifile) gps_data(gpskey)%rfict, gps_data(gpskey)%step_size, &
                gps_data(gpskey)%ray_top, &
               (gps_data(gpskey)%ray_direction(ii), ii=1, 3), &
                gps_data(gpskey)%gpsro_ref_form
endif

end subroutine write_gpsro_ref



 subroutine read_gpsro_ref(gpskey, ifile, fform)
!------------------------------------------------------------------------------
!
! Every GPS observation has its own (metadata) gpskey.
! When you read multiple gps observation sequence files, it is necessary
! to track the total number of metadata gpskeys read, not just the number
! in the current file.
!

integer,          intent(out)          :: gpskey
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform

integer :: keyin    ! the metadata key in the current obs sequence

real(r8) :: nx, ny, nz, rfict0, ds, htop
character(len=6) :: subset0
character(len=8) :: header

if ( .not. module_initialized ) call initialize_module

if (ascii_file_format(fform)) then
   read(ifile, FMT='(a8, i8)') header, keyin    ! throw away keyin
   if(header /= 'gpsroref') then
       call error_handler(E_ERR,'read_gpsro_ref', &
       'Expected header "gpsroref" in input file', source, revision, revdate)
   endif
   read(ifile, *) rfict0, ds, htop, nx, ny, nz, subset0
else
   read(ifile) keyin          ! read and throw away
   read(ifile) rfict0, ds, htop, nx, ny, nz, subset0
endif


! increment key and set all private data for this observation
call set_gpsro_ref(gpskey, nx, ny, nz, rfict0, ds, htop, subset0)

end subroutine read_gpsro_ref


subroutine interactive_gpsro_ref(gpskey)
!----------------------------------------------------------------------
!
! Interactively prompt for the info needed to create a gps refractivity
! observation.  Increments the key number and returns it.

integer, intent(out) :: gpskey

real(r8) :: nx, ny, nz, rfict0, ds, htop
character(len=6) :: subset0
integer :: gpstype


if ( .not. module_initialized ) call initialize_module

!Now interactively obtain reflectivity type information
! valid choices are local or non-local

write(*, *)
write(*, *) 'Beginning to inquire information on reflectivity type.'
write(*, *)

100 continue
write(*, *) 'Enter 1 for local refractivity (GPSREF)'
write(*, *) 'Enter 2 for non-local refractivity/excess phase delay (GPSEXC)'
write(*, *)

read(*,*) gpstype

select case (gpstype)
   case (1)
      subset0 = 'GPSREF'
   case (2)
      subset0 = 'GPSEXC'
   case default
      write(*,*) 'Bad value, must enter 1 or 2'
      goto 100
end select

if (gpstype == 2) then
    ! FIXME:  i have no idea what valid values are for any
   !  of the following items, so i cannot add any error checking or
   !  guidance for the user.

   write(*, *)
   write(*, *) 'Enter X, Y, Z value for ray direction'
   write(*, *)
   read(*,*) nx, ny, nz

   write(*, *)
   write(*, *) 'Enter local curvature radius'
   write(*, *)
   read(*,*) rfict0

   write(*, *)
   write(*, *) 'Enter step size'
   write(*, *)
   read(*,*) ds

   write(*, *)
   write(*, *) 'Enter ray top'
   write(*, *)
   read(*,*) htop
else
   nx = 0.0
   ny = 0.0
   nz = 0.0
   rfict0 = 0.0
   ds = 0.0
   htop = 0.0
endif

! increment key and set all private data for this observation
call set_gpsro_ref(gpskey, nx, ny, nz, rfict0, ds, htop, subset0)

write(*, *)
write(*, *) 'End of specialized section for gps observation data.'
write(*, *) 'You will now have to enter the regular obs information.'
write(*, *)

end subroutine interactive_gpsro_ref

!> Distributed version of get_expected_gpsro_ref
 subroutine get_expected_gpsro_ref(state_handle, ens_size,  location, gpskey, ro_ref, istatus)
!------------------------------------------------------------------------------
!
! Purpose: Calculate GPS RO local refractivity or non_local (integrated)
!          refractivity (excess phase, Sergey Sokolovskiy et al., 2005)
!------------------------------------------------------------------------------
!
! inputs:
!    state_vector:    DART state vector
!
! output parameters:
!    ro_ref: modeled local refractivity (N-1)*1.0e6 or non_local
!            refractivity (excess phase, m)
!            (according to the input data parameter subset)
!    istatus:  =0 normal; =1 outside of domain.
!------------------------------------------------------------------------------
!  Author: Hui Liu
!  Version 1.1: June 15, 2004: Initial version CAM
!
!  Version 1.2: July 29, 2005: revised for new obs_def and WRF
!------------------------------------------------------------------------------

type(ensemble_type), intent(in)  :: state_handle
integer,             intent(in)  :: ens_size
type(location_type), intent(in)  :: location
integer,             intent(in)  :: gpskey
real(r8),            intent(out) :: ro_ref(ens_size)
integer,             intent(out) :: istatus(ens_size)

! local variables.  first set is per ensemble member.
! second set is independent of a particular ensemble member.

real(r8) :: phase(ens_size)
real(r8) :: delta_phase1(ens_size), delta_phase2(ens_size)
real(r8) :: ref_perigee(ens_size), ref1(ens_size), ref2(ens_size)
real(r8) :: ref00(ens_size)
integer  :: this_istatus(ens_size)

real(r8) :: nx, ny, nz       ! unit tangent direction of ray at perigee
real(r8) :: xo, yo, zo       ! perigee location in Cartesian coordinate
real(r8) :: height1, lat1, lon1
real(r8) :: xx, yy, zz, dist_to_perigee
real(r8) :: lon, lat, height, obsloc(3)
integer  :: iter
logical  :: return_now

if ( .not. module_initialized ) call initialize_module

if ( .not. is_vertical(location, "HEIGHT")) then
   write(string1, *) 'vertical location must be height; gps obs key ', gpskey
   call error_handler(E_ERR,'get_expected_gpsro_ref', string1, &
                      source, revision, revdate)
endif

obsloc   = get_location(location)


lon      = obsloc(1)                       ! degree: 0 to 360
lat      = obsloc(2)                       ! degree: -90 to 90
height   = obsloc(3)                       ! (m)

! to use track_status() start out with istatus all success.
istatus = 0

! calculate refractivity at perigee

call ref_local(state_handle, ens_size,  lat, lon, height, ref_perigee, this_istatus)
call track_status(ens_size, this_istatus, ro_ref, istatus, return_now)
if (return_now) return

!>@todo we need to add a different obs type and kind for the local operator,
!> so we can avoid allocating metadata because it isn't needed *at all*
!> for the local operator.  nsc 30oct2015
choosetype: if(gps_data(gpskey)%gpsro_ref_form == 'GPSREF') then
    ! use local refractivity
    where (istatus == 0) ro_ref = ref_perigee * 1.0e6      ! in (N-1)*1.0e6, same with obs

else  ! gps_data(gpskey)%gpsro_ref_form == 'GPSEXC'

    ! otherwise, use non_local refractivity(excess phase delay)

    ! Initialization
    phase = 0.0_r8
    dist_to_perigee =  0.0_r8   ! distance to perigee from a point of the ray

    nx = gps_data(gpskey)%ray_direction(1)
    ny = gps_data(gpskey)%ray_direction(2)
    nz = gps_data(gpskey)%ray_direction(3)

    ! convert location of the perigee from geodetic to Cartesian coordinate

    call geo2carte (height, lat, lon, xo, yo, zo, gps_data(gpskey)%rfict )

    ! currently, use a straight line passing the perigee point as ray model.
    ! later, more sophisticated ray models can be used.
    !
    ! Start the horizontal integrate of the model refractivity along a
    ! straight line path in cartesian coordinate
    !
    ! (x-xo)/a = (y-yo)/b = (z-zo)/c,  (a,b,c) is the line direction

    ref1 = ref_perigee
    ref2 = ref_perigee

    iter = 0
    INTEGRATE: do

       iter = iter + 1
       dist_to_perigee = dist_to_perigee + gps_data(gpskey)%step_size

       !  integrate to one direction of the ray for one step
       ! HK These are now different for each ensemble member
       xx = xo + dist_to_perigee * nx
       yy = yo + dist_to_perigee * ny
       zz = zo + dist_to_perigee * nz

       ! convert the location of the point to geodetic coordinates
       ! height(m), lat, lon(deg)

       call carte2geo(xx, yy, zz, height1, lat1, lon1, gps_data(gpskey)%rfict )
       if (height1 >= gps_data(gpskey)%ray_top) exit INTEGRATE

       ! get the refractivity at this ray point(ref00)
       call ref_local(state_handle, ens_size, lat1, lon1, height1, ref00, this_istatus)
       call track_status(ens_size, this_istatus, ro_ref, istatus, return_now)
       if (return_now) return

       ! get the excess phase due to this ray interval
       where(istatus == 0) delta_phase1 = (ref1 + ref00) * gps_data(gpskey)%step_size * 0.5_r8

       ! save the refractivity for integration of next ray interval
       ref1 = ref00

       ! integrate to the other direction of the ray
       xx = xo - dist_to_perigee * nx
       yy = yo - dist_to_perigee * ny
       zz = zo - dist_to_perigee * nz

       call carte2geo (xx, yy, zz, height1, lat1, lon1, gps_data(gpskey)%rfict )

       ! get the refractivity at this ray point(ref00)
       call ref_local(state_handle, ens_size, lat1, lon1, height1, ref00, this_istatus)
       call track_status(ens_size, this_istatus, ro_ref, istatus, return_now)
       if (return_now) return

       ! get the excess phase due to this ray interval
       where(istatus == 0) delta_phase2 = (ref2 + ref00) * gps_data(gpskey)%step_size * 0.5_r8

       ! save the refractivity for integration of next ray interval
       ref2 = ref00

       where(istatus == 0) phase = phase + delta_phase1 + delta_phase2
       ! print*, 'phase= ',  phase, delta_phase1, delta_phase2

    end do INTEGRATE

    ! finish the integration of the excess phase along the ray

    where(istatus == 0) ro_ref = phase    ! in m

    ! print*, 'xx = ', lon, lat, height, ro_ref

endif choosetype

! make sure return is missing_r8 if failure.
!>@todo is the first line necessary?  i believe the second one
!> is a necessary test.
where (istatus /= 0) ro_ref = missing_r8
where (istatus == 0 .and. ro_ref < 0.0_r8)
   istatus = 5
   ro_ref = missing_r8
endwhere

end subroutine get_expected_gpsro_ref

!> Distributed version.  i removed the unused 'location' argument.
! i changed this to be lat, lon, height - which is a more logical layout of
! the location information.  it used to be height, lat, lon - be careful if
! anyone else calls this routine.  it isn't public so no code outside this
! module can be calling it.   nsc 30 oct 2015

subroutine ref_local(state_handle, ens_size, lat, lon, height, ref00, istatus0)
!------------------------------------------------------------------------------
!
! Calculate local refractivity at any GPS ray point (lat, lon, height)
!
! inputs:
!    lat, lon, height:  GPS observation location (units: degrees, degrees, meters)
!
! output:
!    ref00: modeled local refractivity at ray point(unit: N-1, ~1.0e-4 to e-6)
!
!------------------------------------------------------------------------------

type(ensemble_type), intent(in)  :: state_handle
integer,             intent(in)  :: ens_size
real(r8), intent(in) :: lon, lat, height
real(r8),            intent(out) :: ref00(ens_size)
integer,             intent(out) :: istatus0(ens_size)

real(r8), parameter::  rd = 287.05_r8, rv = 461.51_r8, c1 = 77.6d-6 , &
                       c2 = 3.73d-1,  rdorv = rd/rv

real(r8) :: lon2
real(r8) :: t(ens_size), q(ens_size), p(ens_size), tv(ens_size), ew(ens_size)
integer  :: this_istatus(ens_size)
logical  :: return_now
type(location_type) :: location

if ( .not. module_initialized ) call initialize_module

! for integration of GPS ray path beyond the wraparound point
lon2 = lon
if(lon > 360.0_r8 ) lon2 = lon - 360.0_r8
if(lon <   0.0_r8 ) lon2 = lon + 360.0_r8

location = set_location(lon2, lat, height,  VERTISHEIGHT)

! for sequential sets of calls to interpolate, start with a 0 istatus
! and each call to track_status() will set new failures.
istatus0 = 0
ref00 = missing_r8

call interpolate(state_handle, ens_size, location,  QTY_TEMPERATURE, t, this_istatus)
call track_status(ens_size, this_istatus, ref00, istatus0, return_now)
if (return_now) return

call interpolate(state_handle, ens_size, location, QTY_SPECIFIC_HUMIDITY, q, this_istatus)
call track_status(ens_size, this_istatus, ref00, istatus0, return_now)
if (return_now) return

call interpolate(state_handle, ens_size, location,  QTY_PRESSURE, p, this_istatus)
call track_status(ens_size, this_istatus, ref00, istatus0, return_now)
if (return_now) return

!  required variable units for calculation of GPS refractivity
!   t :  Kelvin, from top to bottom
!   q :  kg/kg, from top to bottom
!   p :  mb

where (istatus0 == 0)
p     = p * 0.01_r8      ! to mb

tv    = t * (1.0_r8+(rv/rd - 1.0_r8)*q)         ! virtual temperature
ew    = q * p/(rdorv + (1.0_r8-rdorv)*q )
ref00 = c1*p/t + c2*ew/(t**2)              ! (N-1)
endwhere

end subroutine ref_local


 subroutine geo2carte (s1, s2, s3, x1, x2, x3, rfict0)
!------------------------------------------------------------------------------
!
!  Converts geodetical coordinates to cartesian with a reference sphere
!------------------------------------------------------------------------------
!  input parameters:
!   s - geodetical coordinates
!        (height (m), latitude (degree), longitude (degree))
!                     -90 to 90           0 to 360
!  output parameters:
!   x - cartesian coordinates (m) connected with the earth(x, y, z-coordinate)
!------------------------------------------------------------------------------
implicit none
real(r8), intent(in)  :: s1, s2, s3, rfict0    ! units: m
real(r8), intent(out) ::   x1, x2 ,x3
real(r8) :: g3, g4

if ( .not. module_initialized ) call initialize_module

g3 = s1 + rfict0
g4 = g3 * cos(s2*DEG2RAD)
x1 = g4 * cos(s3*DEG2RAD)
x2 = g4 * sin(s3*DEG2RAD)
x3 = g3 * sin(s2*DEG2RAD)

end subroutine geo2carte


 subroutine carte2geo (x1, x2, x3, s1, s2, s3, rfict0)
!------------------------------------------------------------------------------
!
!  Converts cartesian coordinates to geodetical.
!
!   input parameters:
!        x - cartesian coordinates (x, y, z-coordinate, unit: m)
!
!   output parameters:
!        s - geodetical coordinates
!            (height (m), latitude (deg), longitude (deg))
!                          -90 to 90         0 to 360
!------------------------------------------------------------------------------
implicit none
real(r8), intent(in)  :: x1, x2, x3, rfict0
real(r8), intent(out) :: s1, s2, s3

real(r8), parameter :: crcl  = 2.0_r8 * PI, &
                       crcl2 = 4.0_r8 * PI

real(r8) :: rho, sphi, azmth

if ( .not. module_initialized ) call initialize_module

rho   = sqrt (x1**2 + x2**2 + x3**2 )
sphi  = x3/rho
s1    = rho - rfict0
s2    = asin (sphi)
azmth = atan2 (x2, x1)
s3    = mod((azmth + crcl2), crcl)

s2    = s2 * RAD2DEG
s3    = s3 * RAD2DEG

end  subroutine carte2geo

end module obs_def_gps_mod

                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../observations/forward_operators/obs_def_gps_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
!No module code needed for ../../../observations/forward_operators/obs_def_reanalysis_bufr_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../observations/forward_operators/obs_def_altimeter_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_altimeter_mod

use           types_mod, only : r8, missing_r8
use       utilities_mod, only : register_module
use        location_mod, only : location_type
use     assim_model_mod, only : interpolate
use        obs_kind_mod, only : QTY_SURFACE_PRESSURE, QTY_SURFACE_ELEVATION
use  ensemble_manager_mod, only : ensemble_type
use obs_def_utilities_mod, only : track_status


implicit none
private

public :: get_expected_altimeter, compute_altimeter

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL$"
character(len=32 ), parameter :: revision = "$Revision$"
character(len=128), parameter :: revdate  = "$Date$"

logical, save :: module_initialized = .false.

contains

!----------------------------------------------------------------------

subroutine initialize_module

call register_module(source, revision, revdate)
module_initialized = .true.

end subroutine initialize_module

!----------------------------------------------------------------------

subroutine get_expected_altimeter(state_handle, ens_size, location, altimeter_setting, istatus)

type(ensemble_type), intent(in)     :: state_handle
integer,             intent(in)     :: ens_size
type(location_type), intent(in)     :: location
real(r8),            intent(out)    :: altimeter_setting(ens_size)     ! altimeter (hPa)
integer,             intent(out)    :: istatus(ens_size)

real(r8) :: psfc(ens_size)                ! surface pressure value   (Pa)
real(r8) :: hsfc(ens_size)                ! surface elevation level  (m above SL)
integer :: psfc_istatus(ens_size)
integer :: hsfc_istatus(ens_size)
logical :: return_now
integer :: imem

real(r8), parameter :: MIN_REALISTIC_ALTIMETER = 880.0_r8      ! (hPa)
real(r8), parameter :: MAX_REALISTIC_ALTIMETER = 1100.0_r8     ! (hPa)

if ( .not. module_initialized ) call initialize_module

istatus = 0 ! Need to initialize this to zero for track_status.
altimeter_setting = missing_r8

! interpolate the surface pressure to the desired location.
! The implicit units of pressure here are Pascals.
call interpolate(state_handle, ens_size, location, QTY_SURFACE_PRESSURE, psfc, psfc_istatus)
call track_status(ens_size, psfc_istatus, altimeter_setting, istatus, return_now)
if (return_now) return

!  interpolate the surface elevation to the desired location
call interpolate(state_handle, ens_size, location, QTY_SURFACE_ELEVATION, hsfc, hsfc_istatus)
call track_status(ens_size, hsfc_istatus, altimeter_setting, istatus, return_now)
if (return_now) return

!  Compute the altimeter setting given surface pressure (hPa) and height (m), altimeter is hPa
do imem = 1, ens_size
   if(istatus(imem) == 0) altimeter_setting(imem) = compute_altimeter(psfc(imem) * 0.01_r8, hsfc(imem))
enddo

where (altimeter_setting <  MIN_REALISTIC_ALTIMETER .or. &
       altimeter_setting >= MAX_REALISTIC_ALTIMETER)
   altimeter_setting = MISSING_R8
   istatus = 1
endwhere

end subroutine get_expected_altimeter

!----------------------------------------------------------------------

function compute_altimeter(psfc, hsfc)

real(r8), parameter :: k1 = 0.190284_r8
real(r8), parameter :: k2 = 8.4228807E-5_r8

real(r8), intent(in) :: psfc  !  (hPa)
real(r8), intent(in) :: hsfc  !  (m above MSL)

real(r8) :: compute_altimeter !  (hPa)

compute_altimeter = ((psfc - 0.3_r8) ** k1 + k2 * hsfc) ** (1.0_r8 / k1)

return
end function compute_altimeter

!----------------------------------------------------------------------------

end module obs_def_altimeter_mod

                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../observations/forward_operators/obs_def_altimeter_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../observations/forward_operators/obs_def_upper_atm_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_upper_atm_mod

use        types_mod, only : r8, MISSING_R8
use    utilities_mod, only : register_module, error_handler, E_ERR, E_MSG
use     location_mod, only : location_type, get_location, set_location, &
                             VERTISHEIGHT, VERTISLEVEL
use  assim_model_mod, only : interpolate
use     obs_kind_mod, only : QTY_ATOMIC_OXYGEN_MIXING_RATIO, &
                             QTY_ATOMIC_H_MIXING_RATIO, &
                             QTY_ION_O_MIXING_RATIO, &
                             QTY_MOLEC_OXYGEN_MIXING_RATIO, &
                             QTY_TEMPERATURE, &
                             QTY_PRESSURE, &
                             QTY_DENSITY, &
                             QTY_DENSITY_ION_E, &
                             QTY_ELECTRON_DENSITY, &
                             QTY_GND_GPS_VTEC, &
                             QTY_GEOPOTENTIAL_HEIGHT, &
                             QTY_GEOMETRIC_HEIGHT, &
                             QTY_O_N2_COLUMN_DENSITY_RATIO
use  ensemble_manager_mod, only : ensemble_type
use obs_def_utilities_mod, only : track_status

implicit none
private
public :: get_expected_upper_atm_density, &
          get_expected_gnd_gps_vtec, &
          get_expected_vtec, &
          get_expected_O_N2_ratio, &
          get_expected_electron_density

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL$"
character(len=32 ), parameter :: revision = "$Revision$"
character(len=128), parameter :: revdate  = "$Date$"

logical, save :: module_initialized = .false.

real(r8), parameter :: N2_molar_mass = 28.0_r8
real(r8), parameter :: O_molar_mass  = 16.0_r8
real(r8), parameter :: O2_molar_mass = 32.0_r8
real(r8), parameter :: H_molar_mass  =  1.0_r8

! WACCM-X; put into common/types_mod.f90?
real(r8), parameter :: kboltz = 1.380648E-23_r8    ! [N*m/K]
real(r8), parameter :: universal_gas_constant = 8314.0_r8 ! [J/K/kmol]
real(r8), parameter :: molar_mass_dry_air = 28.9644_r8
integer,  parameter :: MAXLEVELS = 300 ! more than max levels expected in the model (waccm-x has 126)
character(len=512) :: string1, string2, string3

contains

!-----------------------------------------------------------------------------

subroutine initialize_module

call register_module(source, revision, revdate)
module_initialized = .true.

end subroutine initialize_module

!-----------------------------------------------------------------------------
!>@todo Test RMA.
! Given DART state vector and a location,
! it computes thermospheric neutral density [Kg/m3]
! The istatus variable should be returned as 0 unless there is a problem

subroutine get_expected_upper_atm_density(state_handle, ens_size, location, obs_val, istatus)

type(ensemble_type), intent(in) :: state_handle
integer,             intent(in) :: ens_size
type(location_type), intent(in) :: location
real(r8),           intent(out) :: obs_val(ens_size)
integer,            intent(out) :: istatus(ens_size)

real(r8) :: mmro1(ens_size), mmro2(ens_size) ! mass mixing ratio
real(r8) :: mass_reciprocal(ens_size), pressure(ens_size), temperature(ens_size)
integer  :: this_istatus(ens_size)
logical  :: return_now

if ( .not. module_initialized ) call initialize_module

istatus = 0

! Some models (i.e. GITM) have density as part of the state.
! If it is available, just return it. If density is not state,
! then we need to create it from its constituents.

call interpolate(state_handle, ens_size, location, QTY_DENSITY, obs_val, istatus)
if(any(istatus == 0)) return ! density is part of the state


! This part was implemented for TIEGCM. Check the units for use with
! other models.
istatus(:) = 0
call interpolate(state_handle, ens_size, location, QTY_ATOMIC_OXYGEN_MIXING_RATIO, mmro1, this_istatus)
call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
if (return_now) return

call interpolate(state_handle, ens_size, location, QTY_MOLEC_OXYGEN_MIXING_RATIO, mmro2, this_istatus)
call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
if (return_now) return

call interpolate(state_handle, ens_size, location, QTY_PRESSURE, pressure, this_istatus)
call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
if (return_now) return

call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, temperature, this_istatus)
call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
if (return_now) return


! density [Kg/m3] =  pressure [N/m2] * M [g/mol] / temperature [K] / R [N*m/K/kmol]
! where M is the mean molar mass
! 1/M = sum(wi/Mi) where wi are mass mixing fractions and Mi are individual molar masses

where (istatus == 0)
   mass_reciprocal = mmro1/O_molar_mass + mmro2/O2_molar_mass + &
                    (1.0_r8-mmro1-mmro2)/N2_molar_mass

   obs_val = pressure / mass_reciprocal / temperature / universal_gas_constant
endwhere

end subroutine get_expected_upper_atm_density

!-----------------------------------------------------------------------------

! Given DART state vector and a location,
! it computes ground GPS vertical total electron content
! The istatus variable should be returned as 0 unless there is a problem
!>@todo Is the logic correct in this code on the Trunk
!>  Should you return from the subroutine instead of exiting
!> the loop at exit LEVELS
subroutine get_expected_gnd_gps_vtec(state_handle, ens_size, location, obs_val, istatus)

type(ensemble_type), intent(in) :: state_handle
integer,             intent(in) :: ens_size
type(location_type), intent(in) :: location
real(r8),           intent(out) :: obs_val(ens_size)
integer,            intent(out) :: istatus(ens_size)

! Given a location and the state vector from one of the ensemble members,
! compute the model-predicted total electron content that would be in the
! integrated column from an instrument looking straight down at the tangent point.
! 'istatus' is the return code.  0 is success; any positive value signals an
! error (different values can be used to indicate different error types).
! Negative istatus values are reserved for internal use only by DART.

integer  :: nAlts, iAlt, this_istatus(ens_size)
real(r8), dimension(ens_size, MAXLEVELS) :: ALT, IDensityS_ie  ! num_ens by num levels
real(r8) :: loc_vals(3)
real(r8) :: tec(ens_size)
type(location_type) :: probe
logical  :: return_now

if ( .not. module_initialized ) call initialize_module

istatus = 0     ! must be 0 to use track_status()

loc_vals = get_location(location)

nAlts = 0
LEVELS: do iAlt=1, size(ALT)+1
   ! loop over levels.  if we get to one more than the allocated array size,
   ! this model must have more levels than we expected.  increase array sizes,
   ! recompile, and try again.
   if (iAlt > size(ALT)) then
      write(string1,'(''more than '',i4,'' levels in the model.'')') MAXLEVELS
      string2='increase MAXLEVELS in obs_def_upper_atm_mod.f90, rerun preprocess and recompile.'
      call error_handler(E_ERR, 'get_expected_gnd_gps_vtec', string1, &
           source, revision, revdate, text2=string2)
   endif

   ! At each altitude interpolate the 2D IDensityS_ie to the lon-lat where data
   ! point is located. After this loop we will have a column centered at the data
   ! point's lon-lat and at all model altitudes.
   probe = set_location(loc_vals(1), loc_vals(2), real(iAlt, r8), VERTISLEVEL) !probe is where we have data

   call interpolate(state_handle, ens_size, probe, QTY_DENSITY_ION_E, IDensityS_ie(:, iAlt), this_istatus)
   call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
   if (any(istatus /= 0)) exit LEVELS

   call interpolate(state_handle, ens_size, probe, QTY_GEOPOTENTIAL_HEIGHT, ALT(:, iAlt), this_istatus)
   call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
   if (any(istatus /= 0)) exit LEVELS

   nAlts = nAlts+1
enddo LEVELS

! failed first time through loop - no values to return.
if (nAlts == 0) then
   obs_val(:) = MISSING_R8
   return
endif

! clear the error from the last level and start again?
istatus(:) = 0
tec=0.0_r8 !start with zero for the summation

do iAlt = 1, nAlts-1 !approximate the integral over the altitude as a sum of trapezoids
   !area of a trapezoid: A = (h2-h1) * (f2+f1)/2
   where (istatus == 0) &
      tec = tec + ( ALT(:, iAlt+1)-ALT(:, iAlt) )  * ( IDensityS_ie(:, iAlt+1)+IDensityS_ie(:, iAlt) ) /2.0_r8
enddo
where (istatus == 0) &
   obs_val = tec * 10.0**(-16) !units of TEC are "10^16" #electron/m^2 instead of just "1" #electron/m^2


end subroutine get_expected_gnd_gps_vtec

!-----------------------------------------------------------------------------

! Given DART state vector and a location,
! it computes thermospheric neutral density [Kg/m3]
! The istatus variable should be returned as 0 unless there is a problem

subroutine get_expected_vtec(state_handle, ens_size, location, expected_obs, istatus)

type(ensemble_type), intent(in) :: state_handle
integer,             intent(in) :: ens_size
type(location_type), intent(in) :: location
real(r8),           intent(out) :: expected_obs(ens_size)
integer,            intent(out) :: istatus(ens_size)


if ( .not. module_initialized ) call initialize_module

call error_handler(E_ERR, 'get_expected_vtec', 'routine needs to be written', &
           source, revision, revdate)

expected_obs = missing_r8
istatus = 1

end subroutine get_expected_vtec

!-----------------------------------------------------------------------------

! First, find the number of levels in the model.
! Then, loop down through the levels to create a top-down vertical profile.
!       As we do that, we accumulate the amount of N2 and O, stopping when
!       the N2 reaches 10^21 M^-2. This will probably mean only using part
!       of the 'last' layer.

subroutine get_expected_O_N2_ratio(state_handle, ens_size, location, obs_val, istatus)

type(ensemble_type), intent(in) :: state_handle
integer,             intent(in) :: ens_size
type(location_type), intent(in) :: location
real(r8),           intent(out) :: obs_val(ens_size)
integer,            intent(out) :: istatus(ens_size)

real(r8) :: loc_array(3)
real(r8) :: loc_lon, loc_lat
type(location_type) :: loc
logical  :: return_now

real(r8), parameter :: Max_N2_column_density = 1.0E21_r8

real(r8) :: N2_total(ens_size)
real(r8) :: O_total(ens_size)

real(r8) :: O_mmr(ens_size, MAXLEVELS)
real(r8) :: O2_mmr(ens_size, MAXLEVELS)
real(r8) :: pressure(ens_size, MAXLEVELS)
real(r8) :: temperature(ens_size, MAXLEVELS)
real(r8) :: heights(ens_size, MAXLEVELS)
real(r8) :: thickness(ens_size, MAXLEVELS)
real(r8) :: O_integrated(ens_size)
real(r8) :: N2_integrated(ens_size)

real(r8), allocatable :: N2_mmr(:, :)
real(r8), allocatable :: mbar(:, :)
real(r8), allocatable :: N2_number_density(:, :)
real(r8), allocatable :: total_number_density(:, :)
real(r8), allocatable :: O_number_density(:, :)

real(r8), parameter :: k_constant = 1.381e-23_r8 ! m^2 * kg / s^2 / K
integer :: ilayer, nlevels, nilevels
integer :: this_istatus(ens_size)
real(r8) :: layerfraction(ens_size)

if ( .not. module_initialized ) call initialize_module

istatus = 0

call error_handler(E_ERR, 'get_expected_O_N2_ratio', 'routine not tested', &
           source, revision, revdate, &
           text2='routine in obs_def/obs_def_upper_atm_mod.f90', &
           text3='test and inform the DART development team. Thanks -- Tim.')

if ( .not. module_initialized ) call initialize_module

loc_array = get_location(location) ! loc is in DEGREES
loc_lon   = loc_array(1)
loc_lat   = loc_array(2)

! some variables are defined on interface layers

nilevels = 0
heights = 0.0_r8

!>@todo FIXME: this is setting the same location for VERTISLEVEL
!> as the loop below, so one can *not* be filling the interfaces and
!> the other filling the midpoints.

FILLINTERFACES : do ilayer = 1,MAXLEVELS

   loc = set_location(loc_lon, loc_lat, real(ilayer,r8), VERTISLEVEL)

   call interpolate(state_handle, ens_size, loc, QTY_GEOMETRIC_HEIGHT, heights(:, ilayer), istatus)
   if (any(istatus /= 0)) exit FILLINTERFACES

   nilevels = nilevels + 1

enddo FILLINTERFACES


if (nilevels == 0) then
   obs_val(:) = missing_r8
   return
endif

istatus(:) = 0
thickness = 0.0_r8
thickness(:, 1:nilevels-1) = heights(:, 2:nilevels) - heights(:, 1:nilevels-1)

! Some variables are defined on midpoints of the layers

nlevels = 0

!>@todo FIXME: don't we know how many layers there are now?
FILLMIDPOINTS : do ilayer = 1, MAXLEVELS

   loc = set_location(loc_lon, loc_lat, real(ilayer,r8), VERTISLEVEL)

   call interpolate(state_handle, ens_size, loc, QTY_PRESSURE, pressure(:, ilayer), this_istatus)
   call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
   if (any(istatus /= 0)) exit FILLMIDPOINTS

   call interpolate(state_handle, ens_size, loc, QTY_TEMPERATURE, temperature(:, ilayer), this_istatus)
   call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
   if (return_now) return

   call interpolate(state_handle, ens_size, loc, QTY_ATOMIC_OXYGEN_MIXING_RATIO, O_mmr(:, ilayer), this_istatus)
   call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
   if (return_now) return

   call interpolate(state_handle, ens_size, loc, QTY_MOLEC_OXYGEN_MIXING_RATIO, O2_mmr(:, ilayer), this_istatus)
   call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
   if (return_now) return

   nlevels = nlevels + 1

enddo FILLMIDPOINTS

if (nlevels == 0) then
   obs_val(:) = missing_r8
   return
endif

! Check to make sure we have more interfaces than layers.
!>@todo should this be an error instead of a message?

if (nilevels /= (nlevels+1)) then
   write(string1,*)'Require there to be 1 more interfaces than midpoints.'
   write(string2,*)'Found ',nilevels,' interface layers.'
   write(string3,*)'Found ',nlevels,' midpoint layers.'
   call error_handler(E_MSG,'get_expected_O_N2_ratio', string1, &
              source, revision, revdate, text2=string2,text3=string3)
   where (istatus == 0) obs_val = missing_r8
   where (istatus == 0) istatus = 11
   return
endif

! calculate what we can using array notation

allocate(N2_mmr(ens_size, nlevels), mbar(ens_size, nlevels), total_number_density(ens_size, nlevels), &
         O_number_density(ens_size, nlevels), N2_number_density(ens_size, nlevels))

N2_mmr = 1.0_r8 -  O_mmr(:, 1:nlevels) - O2_mmr(:, 1:nlevels)
  mbar = 1.0_r8/( O2_mmr(:, 1:nlevels)/O2_molar_mass + &
                   O_mmr(:, 1:nlevels)/ O_molar_mass + &
                  N2_mmr(:, 1:nlevels)/N2_molar_mass )

! O_mmr and N2_mmr defined at midpoints, heights defined at interfaces, so the
! calculated thicknesses apply directly to the O and N2 densities.

total_number_density = pressure(:, 1:nlevels) / (k_constant * temperature(:, 1:nlevels))

 O_number_density =  O_mmr(:, 1:nlevels) * mbar /  O_molar_mass * total_number_density
N2_number_density = N2_mmr(:, 1:nlevels) * mbar / N2_molar_mass * total_number_density

if ( 1 == 2 ) then ! DEBUG BLOCK NOT IN USE
   write(*,*)
   do ilayer = nlevels,1,-1
      write(*,*)'DEBUG level, thickness, ens member 1: ',ilayer, thickness(1, ilayer), &
            O_number_density(1, ilayer), N2_number_density(1, ilayer), &
                 temperature(1, ilayer), total_number_density(1, ilayer), &
                 O2_mmr(1, ilayer), O_mmr(1, ilayer), N2_mmr(1, ilayer), mbar(1, ilayer)
   enddo
   write(*,*)
endif

N2_total = 0.0_r8
 O_total = 0.0_r8

TOPDOWN : do ilayer = nlevels,1,-1

   if (ilayer == 1) then
      write(string1,*)'Integrated all the way down to the surface.'
      write(string2,*)'Still do not have ',Max_N2_column_density,' nitrogen molecules per m^2'
      call error_handler(E_MSG,'get_expected_O_N2_ratio', string1, &
                 source, revision, revdate, text2=string2)
      where (istatus == 0) istatus = 2
      return
   endif

   ! integrate over layer thickness
   O_integrated  =  O_number_density(:, ilayer) * thickness(:, ilayer)
   N2_integrated = N2_number_density(:, ilayer) * thickness(:, ilayer)

   where ((N2_total+N2_integrated) >= Max_N2_column_density)
      ! only store part of the final layer so as not to overshoot 10^21 m^-2
      ! Let y2 == N2_total, y = Max_N2_column_density, y1 = N2_total + N2_integrated
      ! the layer fraction is (y - y2)/(y1-y2)
      ! (Max_N2_column_density - N2_total)/(N2_total + N2_integrated - N2_total)
      layerfraction = (Max_N2_column_density - N2_total) / N2_integrated
      N2_total = N2_total + N2_integrated*layerfraction
       O_total =  O_total +  O_integrated*layerfraction
   elsewhere
      N2_total = N2_total + N2_integrated
       O_total =  O_total +  O_integrated
   endwhere

   if (any((N2_total+N2_integrated) >= Max_N2_column_density)) exit TOPDOWN

enddo TOPDOWN

where (istatus == 0) obs_val = O_total / N2_total

deallocate(N2_mmr, mbar, total_number_density, O_number_density, N2_number_density)

end subroutine get_expected_O_N2_ratio


!-----------------------------------------------------------------------------
!> Common interface for electron density forward operators.
!> If there is a variable in the DART state that is the electron density, just use it.
!> If it doesn't exist, try the forward operator from WACCM-X, and return that error code.
!> May be extended to handle other methods of computing electron density.

subroutine get_expected_electron_density(state_handle, ens_size, location, obs_val, istatus)
type(ensemble_type), intent(in)  :: state_handle
integer,             intent(in)  :: ens_size
type(location_type), intent(in)  :: location
integer,             intent(out) :: istatus(ens_size)
real(r8),            intent(out) :: obs_val(ens_size)

call interpolate(state_handle, ens_size, location, QTY_ELECTRON_DENSITY, obs_val, istatus)
if (any(istatus == 0)) return

call get_expected_oxygen_ion_density(state_handle, ens_size, location, obs_val, istatus)

end subroutine get_expected_electron_density


!-----------------------------------------------------------------------------
!> Given DART state vector and a location, it computes O+ density [1/cm^3].
!> The istatus variable should be returned as 0 unless there is a problem.
!> This function was implemented for WACCM-X.
!> Check the units for use with other models.

subroutine get_expected_oxygen_ion_density(state_handle, ens_size, location, obs_val, istatus)
type(ensemble_type), intent(in)  :: state_handle
integer,             intent(in)  :: ens_size
type(location_type), intent(in)  :: location
integer,             intent(out) :: istatus(ens_size)
real(r8),            intent(out) :: obs_val(ens_size)

real(r8), dimension(ens_size)  :: mmr_o1, mmr_o2, mmr_n2, mmr_h1, mmr_op   ! mass mixing ratio
real(r8), dimension(ens_size)  :: mbar, pressure, temperature
integer,  dimension(ens_size)  :: this_istatus
real(r8), dimension(3)  :: loc_vals
logical :: return_now

istatus = 0 ! Need to have istatus = 0 for track_status()

! cam-fv returns volume mixing ratio, not mass mixing ratio. undo for computation below.
call interpolate(state_handle, ens_size, location, QTY_ATOMIC_OXYGEN_MIXING_RATIO, mmr_o1, this_istatus)
call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
if (return_now) return
mmr_o1 = mmr_o1 / (molar_mass_dry_air/O_molar_mass)

call interpolate(state_handle, ens_size, location, QTY_MOLEC_OXYGEN_MIXING_RATIO, mmr_o2, this_istatus)
call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
if (return_now) return
mmr_o2 = mmr_o2 / (molar_mass_dry_air/O2_molar_mass)

call interpolate(state_handle, ens_size, location, QTY_ATOMIC_H_MIXING_RATIO, mmr_h1, this_istatus)
call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
if (return_now) return
mmr_h1 = mmr_h1 / (molar_mass_dry_air/H_molar_mass)

call interpolate(state_handle, ens_size, location, QTY_ION_O_MIXING_RATIO, mmr_op, this_istatus)
call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
if (return_now) return

call interpolate(state_handle, ens_size, location, QTY_PRESSURE, pressure, this_istatus)
call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
if (return_now) return

call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, temperature, this_istatus)
call track_status(ens_size, this_istatus, obs_val, istatus, return_now)
if (return_now) return

!------------------------------------------------------------------------------------------------------
!  Need to get number density (cgs units) from mass mixing ratio (kg/kg).
!  mbar is g/mole, same as rMass units
!       kg/kg * (g/mole)/(g/mole) * (Pa = N/m^2)/((Joules/K = N*m/K) * (K)) = m-3 * 1E-06 = cm-3
!------------------------------------------------------------------------------------------------------
! WACCM-X .i file pressure unit is Pa

loc_vals = get_location(location)

where (istatus == 0)
   mmr_n2 = 1.0_r8 - (mmr_o1 + mmr_o2 + mmr_h1)
   mbar   = 1.0_r8/( mmr_o1/O_molar_mass   &
                   + mmr_o2/O2_molar_mass  &
                   + mmr_h1/H_molar_mass   &
                   + mmr_n2/N2_molar_mass)
   obs_val = mmr_op * mbar/O_molar_mass * pressure/(kboltz * temperature) * 1.E-06_r8
end where

end subroutine get_expected_oxygen_ion_density

end module obs_def_upper_atm_mod
                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../observations/forward_operators/obs_def_upper_atm_mod.f90
!---------------------------------------------------------------------------  

!----------------------------------------------------------------------
! End of any user-defined executable module code
!----------------------------------------------------------------------
!----------------------------------------------------------------------

!----------------------------------------------------------------------
!----------------------------------------------------------------------


!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Start of main obs_def_mod module code
!----------------------------------------------------------------------


module obs_def_mod

! Contains the basic parts of a module for defining and evaluating observation
! definitions. Can evaluate identity observations as is. The DART preprocess
! program is used to add in extra observation kinds at the indicated spots in
! the code.

use        types_mod,      only : r8, i8, missing_i, missing_r8, obstypelength
use    utilities_mod,      only : register_module, error_handler, E_ERR, E_MSG, &
                                  ascii_file_format
use     location_mod,      only : location_type, read_location, write_location, &
                             interactive_location, set_location_missing, &
                             operator(/=)
use time_manager_mod, only : time_type, read_time, write_time, operator(/=), &
                             set_time_missing, interactive_time, set_time, print_time
use  assim_model_mod,      only : get_state_meta_data, interpolate
use     obs_kind_mod,      only : assimilate_this_type_of_obs, evaluate_this_type_of_obs, &
                                  get_name_for_type_of_obs, map_type_of_obs_table, &
                             get_type_of_obs_from_menu, use_ext_prior_this_type_of_obs
use ensemble_manager_mod,  only : ensemble_type
use obs_def_utilities_mod, only : track_status, set_debug_fwd_op

!----------------------------------------------------------------------
! This list is autogenerated by the 'preprocess' program.  To add types
! or kinds, edit the obs_def_xxx_mod.f90 files, and then add/remove them
! from the 'input_files' variable of the &preprocess_nml namelist
! in the model-specific work/input.nml file.
!
! Start of obs_def_xxx_mod specific types and kinds
!----------------------------------------------------------------------

!---------------------------------------------------------------------------  
                                                                              
use obs_kind_mod, only : TEMPERATURE
use obs_kind_mod, only : SPECIFIC_HUMIDITY
use obs_kind_mod, only : PRESSURE
use obs_kind_mod, only : GPSRO_REFRACTIVITY
use obs_kind_mod, only : RADIOSONDE_U_WIND_COMPONENT
use obs_kind_mod, only : RADIOSONDE_V_WIND_COMPONENT
use obs_kind_mod, only : RADIOSONDE_GEOPOTENTIAL_HGT
use obs_kind_mod, only : RADIOSONDE_SURFACE_PRESSURE
use obs_kind_mod, only : RADIOSONDE_TEMPERATURE
use obs_kind_mod, only : RADIOSONDE_SPECIFIC_HUMIDITY
use obs_kind_mod, only : DROPSONDE_U_WIND_COMPONENT
use obs_kind_mod, only : DROPSONDE_V_WIND_COMPONENT
use obs_kind_mod, only : DROPSONDE_SURFACE_PRESSURE
use obs_kind_mod, only : DROPSONDE_TEMPERATURE
use obs_kind_mod, only : DROPSONDE_SPECIFIC_HUMIDITY
use obs_kind_mod, only : AIRCRAFT_U_WIND_COMPONENT
use obs_kind_mod, only : AIRCRAFT_V_WIND_COMPONENT
use obs_kind_mod, only : AIRCRAFT_TEMPERATURE
use obs_kind_mod, only : AIRCRAFT_SPECIFIC_HUMIDITY
use obs_kind_mod, only : ACARS_U_WIND_COMPONENT
use obs_kind_mod, only : ACARS_V_WIND_COMPONENT
use obs_kind_mod, only : ACARS_TEMPERATURE
use obs_kind_mod, only : ACARS_SPECIFIC_HUMIDITY
use obs_kind_mod, only : MARINE_SFC_U_WIND_COMPONENT
use obs_kind_mod, only : MARINE_SFC_V_WIND_COMPONENT
use obs_kind_mod, only : MARINE_SFC_TEMPERATURE
use obs_kind_mod, only : MARINE_SFC_SPECIFIC_HUMIDITY
use obs_kind_mod, only : MARINE_SFC_PRESSURE
use obs_kind_mod, only : LAND_SFC_U_WIND_COMPONENT
use obs_kind_mod, only : LAND_SFC_V_WIND_COMPONENT
use obs_kind_mod, only : LAND_SFC_TEMPERATURE
use obs_kind_mod, only : LAND_SFC_SPECIFIC_HUMIDITY
use obs_kind_mod, only : LAND_SFC_PRESSURE
use obs_kind_mod, only : SAT_U_WIND_COMPONENT
use obs_kind_mod, only : SAT_V_WIND_COMPONENT
use obs_kind_mod, only : ATOV_TEMPERATURE
use obs_kind_mod, only : AIRS_TEMPERATURE
use obs_kind_mod, only : AIRS_SPECIFIC_HUMIDITY
use obs_kind_mod, only : GPS_PRECIPITABLE_WATER
use obs_kind_mod, only : RADIOSONDE_SURFACE_ALTIMETER
use obs_kind_mod, only : DROPSONDE_SURFACE_ALTIMETER
use obs_kind_mod, only : MARINE_SFC_ALTIMETER
use obs_kind_mod, only : LAND_SFC_ALTIMETER
use obs_kind_mod, only : METAR_ALTIMETER
use obs_kind_mod, only : SAT_TEMPERATURE
use obs_kind_mod, only : SAT_TEMPERATURE_ELECTRON
use obs_kind_mod, only : SAT_TEMPERATURE_ION
use obs_kind_mod, only : SAT_DENSITY_NEUTRAL_O3P
use obs_kind_mod, only : SAT_DENSITY_NEUTRAL_O2
use obs_kind_mod, only : SAT_DENSITY_NEUTRAL_N2
use obs_kind_mod, only : SAT_DENSITY_NEUTRAL_N4S
use obs_kind_mod, only : SAT_DENSITY_NEUTRAL_NO
use obs_kind_mod, only : SAT_DENSITY_NEUTRAL_N2D
use obs_kind_mod, only : SAT_DENSITY_NEUTRAL_N2P
use obs_kind_mod, only : SAT_DENSITY_NEUTRAL_H
use obs_kind_mod, only : SAT_DENSITY_NEUTRAL_HE
use obs_kind_mod, only : SAT_DENSITY_NEUTRAL_CO2
use obs_kind_mod, only : SAT_DENSITY_NEUTRAL_O1D
use obs_kind_mod, only : SAT_DENSITY_ION_O4SP
use obs_kind_mod, only : SAT_DENSITY_ION_O2P
use obs_kind_mod, only : SAT_DENSITY_ION_N2P
use obs_kind_mod, only : SAT_DENSITY_ION_NP
use obs_kind_mod, only : SAT_DENSITY_ION_NOP
use obs_kind_mod, only : SAT_DENSITY_ION_O2DP
use obs_kind_mod, only : SAT_DENSITY_ION_O2PP
use obs_kind_mod, only : SAT_DENSITY_ION_HP
use obs_kind_mod, only : SAT_DENSITY_ION_HEP
use obs_kind_mod, only : SAT_DENSITY_ION_E
use obs_kind_mod, only : SAT_VELOCITY_U
use obs_kind_mod, only : SAT_VELOCITY_V
use obs_kind_mod, only : SAT_VELOCITY_W
use obs_kind_mod, only : SAT_VELOCITY_U_ION
use obs_kind_mod, only : SAT_VELOCITY_V_ION
use obs_kind_mod, only : SAT_VELOCITY_W_ION
use obs_kind_mod, only : SAT_VELOCITY_VERTICAL_O3P
use obs_kind_mod, only : SAT_VELOCITY_VERTICAL_O2
use obs_kind_mod, only : SAT_VELOCITY_VERTICAL_N2
use obs_kind_mod, only : SAT_VELOCITY_VERTICAL_N4S
use obs_kind_mod, only : SAT_VELOCITY_VERTICAL_NO
use obs_kind_mod, only : SAT_F107
use obs_kind_mod, only : SAT_RHO
use obs_kind_mod, only : GPS_PROFILE
use obs_kind_mod, only : COSMIC_ELECTRON_DENSITY
use obs_kind_mod, only : GND_GPS_VTEC
use obs_kind_mod, only : CHAMP_DENSITY
use obs_kind_mod, only : MIDAS_TEC
use obs_kind_mod, only : SSUSI_O_N2_RATIO
use obs_kind_mod, only : GPS_VTEC_EXTRAP
use obs_kind_mod, only : SABER_TEMPERATURE
use obs_kind_mod, only : AURAMLS_TEMPERATURE
                                                                              
use obs_kind_mod, only : QTY_TEMPERATURE
use obs_kind_mod, only : QTY_SPECIFIC_HUMIDITY
use obs_kind_mod, only : QTY_PRESSURE
use obs_kind_mod, only : QTY_GPSRO
use obs_kind_mod, only : QTY_U_WIND_COMPONENT
use obs_kind_mod, only : QTY_V_WIND_COMPONENT
use obs_kind_mod, only : QTY_GEOPOTENTIAL_HEIGHT
use obs_kind_mod, only : QTY_SURFACE_PRESSURE
use obs_kind_mod, only : QTY_PRECIPITABLE_WATER
use obs_kind_mod, only : QTY_TEMPERATURE_ELECTRON
use obs_kind_mod, only : QTY_TEMPERATURE_ION
use obs_kind_mod, only : QTY_DENSITY_NEUTRAL_O3P
use obs_kind_mod, only : QTY_DENSITY_NEUTRAL_O2
use obs_kind_mod, only : QTY_DENSITY_NEUTRAL_N2
use obs_kind_mod, only : QTY_DENSITY_NEUTRAL_N4S
use obs_kind_mod, only : QTY_DENSITY_NEUTRAL_NO
use obs_kind_mod, only : QTY_DENSITY_NEUTRAL_N2D
use obs_kind_mod, only : QTY_DENSITY_NEUTRAL_N2P
use obs_kind_mod, only : QTY_DENSITY_NEUTRAL_H
use obs_kind_mod, only : QTY_DENSITY_NEUTRAL_HE
use obs_kind_mod, only : QTY_DENSITY_NEUTRAL_CO2
use obs_kind_mod, only : QTY_DENSITY_NEUTRAL_O1D
use obs_kind_mod, only : QTY_DENSITY_ION_O4SP
use obs_kind_mod, only : QTY_DENSITY_ION_O2P
use obs_kind_mod, only : QTY_DENSITY_ION_N2P
use obs_kind_mod, only : QTY_DENSITY_ION_NP
use obs_kind_mod, only : QTY_DENSITY_ION_NOP
use obs_kind_mod, only : QTY_DENSITY_ION_O2DP
use obs_kind_mod, only : QTY_DENSITY_ION_O2PP
use obs_kind_mod, only : QTY_DENSITY_ION_HP
use obs_kind_mod, only : QTY_DENSITY_ION_HEP
use obs_kind_mod, only : QTY_DENSITY_ION_E
use obs_kind_mod, only : QTY_VELOCITY_U
use obs_kind_mod, only : QTY_VELOCITY_V
use obs_kind_mod, only : QTY_VELOCITY_W
use obs_kind_mod, only : QTY_VELOCITY_U_ION
use obs_kind_mod, only : QTY_VELOCITY_V_ION
use obs_kind_mod, only : QTY_VELOCITY_W_ION
use obs_kind_mod, only : QTY_VELOCITY_VERTICAL_O3P
use obs_kind_mod, only : QTY_VELOCITY_VERTICAL_O2
use obs_kind_mod, only : QTY_VELOCITY_VERTICAL_N2
use obs_kind_mod, only : QTY_VELOCITY_VERTICAL_N4S
use obs_kind_mod, only : QTY_VELOCITY_VERTICAL_NO
use obs_kind_mod, only : QTY_1D_PARAMETER
use obs_kind_mod, only : QTY_DENSITY
use obs_kind_mod, only : QTY_ELECTRON_DENSITY
use obs_kind_mod, only : 		           QTY_GND_GPS_VTEC
use obs_kind_mod, only : QTY_VERTICAL_TEC
use obs_kind_mod, only : QTY_O_N2_COLUMN_DENSITY_RATIO
                                                                              
!---------------------------------------------------------------------------  
                                                                              

!----------------------------------------------------------------------
! End of obs_def_xxx_mod specific types and kinds
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! This section is autogenerated by the 'preprocess' program.
!
! Start of any obs_def_xxx_mod specific use statements
!----------------------------------------------------------------------

! If any observation types required specialized code, the module code
! will have been added above, and now a use statement will be generated
! here so the generic obs_def_mod has access to the code.

  use obs_def_gps_mod, only : get_expected_gpsro_ref, interactive_gpsro_ref, &
                              read_gpsro_ref, write_gpsro_ref
   use obs_def_altimeter_mod, only : get_expected_altimeter, compute_altimeter
  use obs_def_upper_atm_mod, only : get_expected_upper_atm_density
  use obs_def_upper_atm_mod, only : get_expected_gnd_gps_vtec
  use obs_def_upper_atm_mod, only : get_expected_vtec
  use obs_def_upper_atm_mod, only : get_expected_O_N2_ratio
  use obs_def_upper_atm_mod, only : get_expected_electron_density

!----------------------------------------------------------------------
! End of any obs_def_xxx_mod specific use statements
!----------------------------------------------------------------------


implicit none
private

interface assignment(=)
   module procedure copy_obs_def
end interface

interface operator(==)
   module procedure eq_obs_def
end interface

interface operator(/=)
   module procedure ne_obs_def
end interface

public :: init_obs_def, get_obs_def_key, get_obs_def_location, get_obs_def_type_of_obs, &
   get_obs_def_time, get_obs_def_error_variance, set_obs_def_location, &
   set_obs_def_type_of_obs, set_obs_def_time, set_obs_def_error_variance, &
   set_obs_def_key, interactive_obs_def, write_obs_def, read_obs_def, &
   obs_def_type, get_expected_obs_from_def_distrib_state, destroy_obs_def, copy_obs_def, &
   assignment(=), set_obs_def_external_FO, set_obs_def_write_external_FO, &
   eq_obs_def, ne_obs_def, operator(==), operator(/=), print_obs_def

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL$"
character(len=32 ), parameter :: revision = "$Revision$"
character(len=128), parameter :: revdate  = "$Date$"

! FIXME: should write_external_FO be some kind of global instead of
! being per-obs?

type obs_def_type
! In revision, obs_kind module is responsible for taking care of
! identity obs kinds, too
   private
   type(location_type)   :: location   ! center of mass, so to speak
   integer               :: kind       ! actually type
   type(time_type)       :: time
   real(r8)              :: error_variance
   integer               :: key        ! Used by specialized observation types
   logical               :: write_external_FO = .false.
   logical               :: has_external_FO   = .false.
   real(r8), allocatable :: external_FO(:)
   integer               :: external_FO_key
   integer               :: ens_size
end type obs_def_type

logical, save :: module_initialized = .false.

! define a fixed integer code that specifies whether a record
! in a binary obs_sequence file is a precomputed FO rather than a time_type
integer, parameter :: external_prior_code = -123

contains

!----------------------------------------------------------------------------

subroutine initialize_module

call register_module(source, revision, revdate)
module_initialized = .true.

! Note that there is no namelist for this module now that
! obs_kind has been revised

end subroutine initialize_module


!----------------------------------------------------------------------------

subroutine init_obs_def(obs_def, location, kind, time, error_variance)
! Need to add additional component arguments as optionals as needed

! Constructor for an obs_def

type(obs_def_type), intent(out) :: obs_def
type(location_type), intent(in) :: location
integer,             intent(in) :: kind
type(time_type),     intent(in) :: time
real(r8),            intent(in) :: error_variance

if ( .not. module_initialized ) call initialize_module

obs_def%location = location
obs_def%kind = kind
obs_def%time = time
obs_def%error_variance = error_variance
! No key assigned for standard observation defs
obs_def%key = -1

end subroutine init_obs_def

!---------------------------------------------------------------------

subroutine copy_obs_def(obs_def1, obs_def2)

! Copy function to be overloaded with '='

type(obs_def_type), intent(out) :: obs_def1
type(obs_def_type), intent(in) :: obs_def2

if ( .not. module_initialized ) call initialize_module

obs_def1%location       = obs_def2%location
obs_def1%kind           = obs_def2%kind
obs_def1%time           = obs_def2%time
obs_def1%error_variance = obs_def2%error_variance
obs_def1%key            = obs_def2%key
!deallocate(obs_def1%platform_qc)
!allocate(obs_def1%platform_qc(size(obs_def2%platform_qc))
! Should this be pointer assignment or regular
!obs_def1%platform_qc >= or == obs_def2%platform_qc
!obs_def1%aperture = obs_def2%aperture

obs_def1%has_external_FO = obs_def2%has_external_FO
if ( obs_def1%has_external_FO ) then
   call set_obs_def_external_FO(obs_def1, obs_def1%has_external_FO, obs_def2%write_external_FO,  &
                                obs_def2%external_FO_key, obs_def2%ens_size, obs_def2%external_FO)
endif

end subroutine copy_obs_def

!---------------------------------------------------------------------

subroutine print_obs_def(obs_def)

type(obs_def_type), intent(in) :: obs_def

character(len=256) :: string

if ( .not. module_initialized ) call initialize_module

call write_location(0, obs_def%location, charstring=string)
call error_handler(E_MSG, '', 'location: '//trim(string))

write(string, *) obs_def%kind, ', ', trim(get_name_for_type_of_obs(obs_def%kind))
call error_handler(E_MSG, '', 'type: '//trim(string))

call print_time(obs_def%time, ' time: ')

write(string, *) obs_def%error_variance
call error_handler(E_MSG, '', 'error variance: '//trim(string))

write(string, *) obs_def%key
call error_handler(E_MSG, '', 'private key: '//trim(string))

end subroutine print_obs_def

!---------------------------------------------------------------------

function eq_obs_def(obs_def1, obs_def2)

! Compare function to be overloaded with '=='

type(obs_def_type), intent(in) :: obs_def1
type(obs_def_type), intent(in) :: obs_def2
logical :: eq_obs_def

if ( .not. module_initialized ) call initialize_module

eq_obs_def = .false.

if (obs_def1%location       /= obs_def2%location) return
if (obs_def1%kind           /= obs_def2%kind) return
if (obs_def1%time           /= obs_def2%time) return
if (obs_def1%error_variance /= obs_def2%error_variance) return

! FIXME: should this be tested as well?  it could be different
! for identical obs - it's the key target that needs testing
! and that's type dependent.  for now, avoid testing it.
!if (obs_def1%key            /= obs_def2%key) return

eq_obs_def = .true.

end function eq_obs_def

!----------------------------------------------------------------------------

function ne_obs_def(obs_def1, obs_def2)

! Compare function to be overloaded with '/='

type(obs_def_type), intent(in) :: obs_def1
type(obs_def_type), intent(in) :: obs_def2
logical :: ne_obs_def

ne_obs_def = .not. eq_obs_def(obs_def1, obs_def2)

end function ne_obs_def

!----------------------------------------------------------------------------

function get_obs_def_key(obs_def)

type(obs_def_type), intent(in) :: obs_def
integer                        :: get_obs_def_key

if ( .not. module_initialized ) call initialize_module

get_obs_def_key = obs_def%key

end function get_obs_def_key

!----------------------------------------------------------------------------

function get_obs_def_error_variance(obs_def)

type(obs_def_type), intent(in) :: obs_def
real(r8)                       :: get_obs_def_error_variance

if ( .not. module_initialized ) call initialize_module

get_obs_def_error_variance = obs_def%error_variance

end function get_obs_def_error_variance

!----------------------------------------------------------------------------

function get_obs_def_location(obs_def)

! Returns observation location.

type(location_type)            :: get_obs_def_location
type(obs_def_type), intent(in) :: obs_def

if ( .not. module_initialized ) call initialize_module

get_obs_def_location = obs_def%location

end function get_obs_def_location

!----------------------------------------------------------------------------

function get_obs_def_type_of_obs(obs_def)

! Returns observation kind

integer                        :: get_obs_def_type_of_obs
type(obs_def_type), intent(in) :: obs_def

if ( .not. module_initialized ) call initialize_module

get_obs_def_type_of_obs = obs_def%kind

end function get_obs_def_type_of_obs

!----------------------------------------------------------------------------

function get_obs_def_time(obs_def)

! Returns observation time

type(time_type)                :: get_obs_def_time
type(obs_def_type), intent(in) :: obs_def

if ( .not. module_initialized ) call initialize_module

get_obs_def_time = obs_def%time

end function get_obs_def_time

!----------------------------------------------------------------------------

subroutine set_obs_def_location(obs_def, location)

! Sets the location of an obs_def

type(obs_def_type), intent(inout) :: obs_def
type(location_type),   intent(in) :: location

if ( .not. module_initialized ) call initialize_module

obs_def%location = location

end subroutine set_obs_def_location

!----------------------------------------------------------------------------

subroutine set_obs_def_error_variance(obs_def, error_variance)

! Sets the error variance of an obs_def

type(obs_def_type), intent(inout) :: obs_def
real(r8), intent(in) :: error_variance

if ( .not. module_initialized ) call initialize_module

obs_def%error_variance = error_variance

end subroutine set_obs_def_error_variance

!----------------------------------------------------------------------------

subroutine set_obs_def_key(obs_def, key)

! Sets the key of an obs_def

type(obs_def_type), intent(inout) :: obs_def
integer,            intent(in)    :: key

if ( .not. module_initialized ) call initialize_module

obs_def%key = key

end subroutine set_obs_def_key

!----------------------------------------------------------------------------

subroutine set_obs_def_external_FO(obs_def, has_external_FO, write_external_FO, external_FO_key, &
                                    ens_size, external_FO_values)

! Sets whether an obs_def has an external prior associated with it

type(obs_def_type), intent(inout) :: obs_def
logical,            intent(in)    :: has_external_FO
logical,            intent(in)    :: write_external_FO
integer,            intent(in)    :: external_FO_key, ens_size
real(r8),           intent(in)    :: external_FO_values(ens_size)

if ( .not. module_initialized ) call initialize_module

if ( .not. allocated(obs_def%external_FO)) allocate(obs_def%external_FO(ens_size))

obs_def%has_external_FO   = has_external_FO
obs_def%write_external_FO = write_external_FO
obs_def%external_FO_key   = external_FO_key
obs_def%ens_size          = ens_size
obs_def%external_FO(1:ens_size)  = external_FO_values(1:ens_size)

end subroutine set_obs_def_external_FO

!----------------------------------------------------------------------------

subroutine set_obs_def_write_external_FO(obs_def, write_external_FO)

! Sets whether to write out the external FO values or not.
! Should be true for programs which create these obs in the first place,
! should also be true for programs like the obs_sequence_tool.  Should be
! false for filter.

type(obs_def_type), intent(inout) :: obs_def
logical,            intent(in)    :: write_external_FO

if ( .not. module_initialized ) call initialize_module

obs_def%write_external_FO = write_external_FO

end subroutine set_obs_def_write_external_FO

!----------------------------------------------------------------------------

subroutine set_obs_def_type_of_obs(obs_def, kind)

! Sets the kind of an obs_def

type(obs_def_type), intent(inout) :: obs_def
integer,               intent(in) :: kind

if ( .not. module_initialized ) call initialize_module

obs_def%kind = kind

end subroutine set_obs_def_type_of_obs

!----------------------------------------------------------------------------

subroutine set_obs_def_time(obs_def, time)

! Sets the time of an obs_def

type(obs_def_type), intent(inout) :: obs_def
type(time_type), intent(in) :: time

if ( .not. module_initialized ) call initialize_module

obs_def%time = time

end subroutine set_obs_def_time

!----------------------------------------------------------------------------

subroutine get_expected_obs_from_def_distrib_state(state_handle, ens_size, copy_indices, key, obs_def, obs_kind_ind, &
   state_time, isprior, assimilate_this_ob, evaluate_this_ob, expected_obs, istatus)

! Compute forward operator for a particular obs_def
type(ensemble_type), intent(in)  :: state_handle
integer,             intent(in)  :: ens_size
integer,             intent(in)  :: copy_indices(ens_size)
integer,             intent(in)  :: key
type(obs_def_type),  intent(in)  :: obs_def
integer,             intent(in)  :: obs_kind_ind
type(time_type),     intent(in)  :: state_time
logical,             intent(in)  :: isprior
integer,             intent(out) :: istatus(ens_size)
logical,             intent(out) :: assimilate_this_ob, evaluate_this_ob
real(r8),            intent(out) :: expected_obs(ens_size)


type(location_type) :: location
type(time_type)     :: obs_time
integer             :: obs_key
real(r8)            :: error_var
logical             :: use_precomputed_FO

! Load up the assimilate and evaluate status for this observation kind
assimilate_this_ob = assimilate_this_type_of_obs(obs_kind_ind)
evaluate_this_ob = evaluate_this_type_of_obs(obs_kind_ind)
use_precomputed_FO = use_ext_prior_this_type_of_obs(obs_kind_ind)

! If not being assimilated or evaluated return with missing_r8 and istatus 0
if(assimilate_this_ob .or. evaluate_this_ob) then
   ! for speed, access directly instead of using accessor functions
   location  = obs_def%location
   obs_time  = obs_def%time
   obs_key   = obs_def%key
   error_var = obs_def%error_variance

   ! the decision process here is that if some external source computed
   ! the prior forward operator values then we can use them or not, but
   ! if we use them there is no way to compute a consistent posterior.
   ! so the posteriors are always marked as 'failed forward operator'.
   if (use_precomputed_FO) then
      if (isprior) then
         if ( obs_def%has_external_FO ) then
            expected_obs(:) = obs_def%external_FO(:)
            istatus = 0
         else
            call error_handler(E_ERR, 'get_expected_obs_from_def', &
                  'Attempt to access an external FO that is not present in the observation information.', &
                   source, revision, revdate, text2='observation type '//trim(get_name_for_type_of_obs(obs_def%kind)))
         endif
      else ! posterior - missing value
         expected_obs(:) = missing_r8
         istatus = 1
      endif
   else
      ! Compute the forward operator.  In spite of the variable name,
      ! obs_kind_ind is in fact a 'type' index number.  use the function
      ! get_quantity_for_type_of_obs from the obs_kind_mod if you want to map
      ! from a specific type to a generic kind.  the third argument of
      ! a call to the 'interpolate()' function must be a kind index and
      ! not a type.  normally the preprocess program does this for you.
      select case(obs_kind_ind)

         ! arguments available to an obs_def forward operator code are:
         !   state_handle -- to access the state vector
         !   ens_size     -- the number of ensemble members to do at once (between 1 and ens_size)
         !   copy_indices -- the indicies the ensemble members (between 1 and ens_size)
         !   location     -- observation location
         !   obs_kind_ind -- the index of the observation specific type
         !   obs_time     -- the time of the observation
         !   error_var    -- the observation error variance
         !   isprior      -- true for prior eval; false for posterior
         !
         ! the routine must return values for:
         !   expected_obs -- the computed forward operator values for all ensemble members
         !   istatus -- return code: 0=ok, >0 is error, <0 reserved for system use
         !
         ! to call interpolate() directly, the arg list MUST BE:
         !  interpolate(state_handle, ens_size, location, QTY_xxx, expected_obs, istatus)
         !
         ! the preprocess program generates lines like this automatically,
         ! and this matches the interfaces in each model_mod.f90 file.
         !
         ! CASE statements and algorithms for specific observation kinds are
         ! inserted here by the DART preprocess program.

         case(GPSRO_REFRACTIVITY)
            call get_expected_gpsro_ref(state_handle, ens_size,  location, obs_def%key, expected_obs, istatus)
         case(RADIOSONDE_SURFACE_ALTIMETER, DROPSONDE_SURFACE_ALTIMETER, MARINE_SFC_ALTIMETER, &
              LAND_SFC_ALTIMETER, METAR_ALTIMETER)
            call get_expected_altimeter(state_handle, ens_size, location, expected_obs, istatus)
 case(SAT_RHO)
      call get_expected_upper_atm_density(state_handle, ens_size, location, expected_obs, istatus)
 case(CHAMP_DENSITY)
      call get_expected_upper_atm_density(state_handle, ens_size, location, expected_obs, istatus)
 case(MIDAS_TEC)
      call get_expected_vtec(state_handle, ens_size, location, expected_obs, istatus)
 case(GND_GPS_VTEC)
      call get_expected_gnd_gps_vtec(state_handle, ens_size, location, expected_obs, istatus)
 case(SSUSI_O_N2_RATIO)
      call get_expected_O_N2_ratio(state_handle, ens_size, location, expected_obs, istatus)
 case(COSMIC_ELECTRON_DENSITY)
      call get_expected_electron_density(state_handle, ens_size, location, expected_obs, istatus)
      case(TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(SPECIFIC_HUMIDITY)
         call interpolate(state_handle, ens_size, location, QTY_SPECIFIC_HUMIDITY, expected_obs, istatus)
      case(PRESSURE)
         call interpolate(state_handle, ens_size, location, QTY_PRESSURE, expected_obs, istatus)
      case(RADIOSONDE_U_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_U_WIND_COMPONENT, expected_obs, istatus)
      case(RADIOSONDE_V_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_V_WIND_COMPONENT, expected_obs, istatus)
      case(RADIOSONDE_GEOPOTENTIAL_HGT)
         call interpolate(state_handle, ens_size, location, QTY_GEOPOTENTIAL_HEIGHT, expected_obs, istatus)
      case(RADIOSONDE_SURFACE_PRESSURE)
         call interpolate(state_handle, ens_size, location, QTY_SURFACE_PRESSURE, expected_obs, istatus)
      case(RADIOSONDE_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(RADIOSONDE_SPECIFIC_HUMIDITY)
         call interpolate(state_handle, ens_size, location, QTY_SPECIFIC_HUMIDITY, expected_obs, istatus)
      case(DROPSONDE_U_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_U_WIND_COMPONENT, expected_obs, istatus)
      case(DROPSONDE_V_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_V_WIND_COMPONENT, expected_obs, istatus)
      case(DROPSONDE_SURFACE_PRESSURE)
         call interpolate(state_handle, ens_size, location, QTY_SURFACE_PRESSURE, expected_obs, istatus)
      case(DROPSONDE_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(DROPSONDE_SPECIFIC_HUMIDITY)
         call interpolate(state_handle, ens_size, location, QTY_SPECIFIC_HUMIDITY, expected_obs, istatus)
      case(AIRCRAFT_U_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_U_WIND_COMPONENT, expected_obs, istatus)
      case(AIRCRAFT_V_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_V_WIND_COMPONENT, expected_obs, istatus)
      case(AIRCRAFT_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(AIRCRAFT_SPECIFIC_HUMIDITY)
         call interpolate(state_handle, ens_size, location, QTY_SPECIFIC_HUMIDITY, expected_obs, istatus)
      case(ACARS_U_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_U_WIND_COMPONENT, expected_obs, istatus)
      case(ACARS_V_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_V_WIND_COMPONENT, expected_obs, istatus)
      case(ACARS_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(ACARS_SPECIFIC_HUMIDITY)
         call interpolate(state_handle, ens_size, location, QTY_SPECIFIC_HUMIDITY, expected_obs, istatus)
      case(MARINE_SFC_U_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_U_WIND_COMPONENT, expected_obs, istatus)
      case(MARINE_SFC_V_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_V_WIND_COMPONENT, expected_obs, istatus)
      case(MARINE_SFC_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(MARINE_SFC_SPECIFIC_HUMIDITY)
         call interpolate(state_handle, ens_size, location, QTY_SPECIFIC_HUMIDITY, expected_obs, istatus)
      case(MARINE_SFC_PRESSURE)
         call interpolate(state_handle, ens_size, location, QTY_SURFACE_PRESSURE, expected_obs, istatus)
      case(LAND_SFC_U_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_U_WIND_COMPONENT, expected_obs, istatus)
      case(LAND_SFC_V_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_V_WIND_COMPONENT, expected_obs, istatus)
      case(LAND_SFC_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(LAND_SFC_SPECIFIC_HUMIDITY)
         call interpolate(state_handle, ens_size, location, QTY_SPECIFIC_HUMIDITY, expected_obs, istatus)
      case(LAND_SFC_PRESSURE)
         call interpolate(state_handle, ens_size, location, QTY_SURFACE_PRESSURE, expected_obs, istatus)
      case(SAT_U_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_U_WIND_COMPONENT, expected_obs, istatus)
      case(SAT_V_WIND_COMPONENT)
         call interpolate(state_handle, ens_size, location, QTY_V_WIND_COMPONENT, expected_obs, istatus)
      case(ATOV_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(AIRS_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(AIRS_SPECIFIC_HUMIDITY)
         call interpolate(state_handle, ens_size, location, QTY_SPECIFIC_HUMIDITY, expected_obs, istatus)
      case(GPS_PRECIPITABLE_WATER)
         call interpolate(state_handle, ens_size, location, QTY_PRECIPITABLE_WATER, expected_obs, istatus)
      case(SAT_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(SAT_TEMPERATURE_ELECTRON)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE_ELECTRON, expected_obs, istatus)
      case(SAT_TEMPERATURE_ION)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE_ION, expected_obs, istatus)
      case(SAT_DENSITY_NEUTRAL_O3P)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_NEUTRAL_O3P, expected_obs, istatus)
      case(SAT_DENSITY_NEUTRAL_O2)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_NEUTRAL_O2, expected_obs, istatus)
      case(SAT_DENSITY_NEUTRAL_N2)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_NEUTRAL_N2, expected_obs, istatus)
      case(SAT_DENSITY_NEUTRAL_N4S)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_NEUTRAL_N4S, expected_obs, istatus)
      case(SAT_DENSITY_NEUTRAL_NO)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_NEUTRAL_NO, expected_obs, istatus)
      case(SAT_DENSITY_NEUTRAL_N2D)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_NEUTRAL_N2D, expected_obs, istatus)
      case(SAT_DENSITY_NEUTRAL_N2P)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_NEUTRAL_N2P, expected_obs, istatus)
      case(SAT_DENSITY_NEUTRAL_H)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_NEUTRAL_H, expected_obs, istatus)
      case(SAT_DENSITY_NEUTRAL_HE)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_NEUTRAL_HE, expected_obs, istatus)
      case(SAT_DENSITY_NEUTRAL_CO2)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_NEUTRAL_CO2, expected_obs, istatus)
      case(SAT_DENSITY_NEUTRAL_O1D)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_NEUTRAL_O1D, expected_obs, istatus)
      case(SAT_DENSITY_ION_O4SP)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_ION_O4SP, expected_obs, istatus)
      case(SAT_DENSITY_ION_O2P)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_ION_O2P, expected_obs, istatus)
      case(SAT_DENSITY_ION_N2P)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_ION_N2P, expected_obs, istatus)
      case(SAT_DENSITY_ION_NP)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_ION_NP, expected_obs, istatus)
      case(SAT_DENSITY_ION_NOP)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_ION_NOP, expected_obs, istatus)
      case(SAT_DENSITY_ION_O2DP)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_ION_O2DP, expected_obs, istatus)
      case(SAT_DENSITY_ION_O2PP)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_ION_O2PP, expected_obs, istatus)
      case(SAT_DENSITY_ION_HP)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_ION_HP, expected_obs, istatus)
      case(SAT_DENSITY_ION_HEP)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_ION_HEP, expected_obs, istatus)
      case(SAT_DENSITY_ION_E)
         call interpolate(state_handle, ens_size, location, QTY_DENSITY_ION_E, expected_obs, istatus)
      case(SAT_VELOCITY_U)
         call interpolate(state_handle, ens_size, location, QTY_VELOCITY_U, expected_obs, istatus)
      case(SAT_VELOCITY_V)
         call interpolate(state_handle, ens_size, location, QTY_VELOCITY_V, expected_obs, istatus)
      case(SAT_VELOCITY_W)
         call interpolate(state_handle, ens_size, location, QTY_VELOCITY_W, expected_obs, istatus)
      case(SAT_VELOCITY_U_ION)
         call interpolate(state_handle, ens_size, location, QTY_VELOCITY_U_ION, expected_obs, istatus)
      case(SAT_VELOCITY_V_ION)
         call interpolate(state_handle, ens_size, location, QTY_VELOCITY_V_ION, expected_obs, istatus)
      case(SAT_VELOCITY_W_ION)
         call interpolate(state_handle, ens_size, location, QTY_VELOCITY_W_ION, expected_obs, istatus)
      case(SAT_VELOCITY_VERTICAL_O3P)
         call interpolate(state_handle, ens_size, location, QTY_VELOCITY_VERTICAL_O3P, expected_obs, istatus)
      case(SAT_VELOCITY_VERTICAL_O2)
         call interpolate(state_handle, ens_size, location, QTY_VELOCITY_VERTICAL_O2, expected_obs, istatus)
      case(SAT_VELOCITY_VERTICAL_N2)
         call interpolate(state_handle, ens_size, location, QTY_VELOCITY_VERTICAL_N2, expected_obs, istatus)
      case(SAT_VELOCITY_VERTICAL_N4S)
         call interpolate(state_handle, ens_size, location, QTY_VELOCITY_VERTICAL_N4S, expected_obs, istatus)
      case(SAT_VELOCITY_VERTICAL_NO)
         call interpolate(state_handle, ens_size, location, QTY_VELOCITY_VERTICAL_NO, expected_obs, istatus)
      case(SAT_F107)
         call interpolate(state_handle, ens_size, location, QTY_1D_PARAMETER, expected_obs, istatus)
      case(GPS_PROFILE)
         call interpolate(state_handle, ens_size, location, QTY_ELECTRON_DENSITY, expected_obs, istatus)
      case(GPS_VTEC_EXTRAP)
         call interpolate(state_handle, ens_size, location, QTY_VERTICAL_TEC, expected_obs, istatus)
      case(SABER_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)
      case(AURAMLS_TEMPERATURE)
         call interpolate(state_handle, ens_size, location, QTY_TEMPERATURE, expected_obs, istatus)

         ! If the observation kind is not available, it is an error. The DART
         ! preprocess program should provide code for all available kinds.
         case DEFAULT
            call error_handler(E_ERR, 'get_expected_obs_from_def', &
               'Attempt to evaluate or assimilate undefined obs_kind type.', &
                source, revision, revdate)
      end select
   endif
else
   ! Not computing forward operator for this kind
   expected_obs(:) = missing_r8
   istatus = 0
endif

end subroutine get_expected_obs_from_def_distrib_state



  subroutine read_obs_def(ifile, obs_def, key, obs_val, fform)
!----------------------------------------------------------------------------
! subroutine read_obs_def(ifile, obs_def, key, obs_val, fform)
!
! ifile
! obs_def
! key
! obs_val    needed if you want to perform operations based on value
! fform
!
! Reads an obs_def from file which is just an integer unit number in the
! current preliminary implementation.

integer,                    intent(in)    :: ifile
type(obs_def_type),         intent(inout) :: obs_def
integer,                    intent(in)    :: key
real(r8),                   intent(inout) :: obs_val
character(len=*), optional, intent(in)    :: fform

character(len=5)  :: header
integer           :: o_index
logical           :: is_ascii
character(len=32) :: fileformat   ! here for backwards compatibility only
character(len=256) :: errstring
character(len=11) :: header_external_FO
integer           :: ii, secs,days
character(len=128) :: string
logical           :: time_set
integer, save     :: counter = 0

if ( .not. module_initialized ) call initialize_module

is_ascii = ascii_file_format(fform)

! here for backwards compatibility only; after the next release,
! remove this and force people in their own obs_def_xxx_mod.f90 code
! to set the last arg to read/write to be fform instead of fileformat
if (is_ascii) then
   fileformat = 'formatted'
else
   fileformat = 'unformatted'
endif

! Begin by reading five character ascii header, then location, kind, error variance, index

! Need to add additional error checks on read
if (is_ascii) then
   read(ifile, '(a5)') header
   if(header /= 'obdef') then
      write(errstring, *) 'read "//header//" instead'
      call error_handler(E_ERR,'read_obs_def', &
         'Expected header "obdef" in input file', &
          source, revision, revdate, text2=errstring)
   endif
endif

! Read the location, kind, time and error variance
obs_def%location = read_location(ifile, fform)
if (is_ascii) then
   read(ifile, '(a5)' ) header
   if(header /= 'kind ') then
      write(errstring, *) 'read "//header//" instead'
      call error_handler(E_ERR,'read_kind', &
         'Expected kind header "kind " in input file', &
          source, revision, revdate, text2=errstring)
   endif
   read(ifile, *) o_index
else
   read(ifile)    o_index
endif

! Negative value is identity obs, doesn't need mapped
! Positive value must use mapping to get to proper index in obs_kind
if(o_index < 0) then
   obs_def%kind = o_index
else
   obs_def%kind = map_type_of_obs_table(o_index)
endif

! This kind may have its own module that needs to read more
select case(obs_def%kind)
   ! More complicated kinds may require reading additional information from
   ! an observation sequence file. Case code to do this is inserted here by
   ! the DART preprocess program.

         case(GPSRO_REFRACTIVITY)
            call read_gpsro_ref(obs_def%key, ifile, fform)
         case(RADIOSONDE_SURFACE_ALTIMETER, DROPSONDE_SURFACE_ALTIMETER, MARINE_SFC_ALTIMETER, &
              LAND_SFC_ALTIMETER, METAR_ALTIMETER)
            continue
 case(SAT_RHO)
      continue
 case(CHAMP_DENSITY)
      continue
 case(MIDAS_TEC)
      continue
 case(GND_GPS_VTEC)
      continue
 case(SSUSI_O_N2_RATIO)
      continue
 case(COSMIC_ELECTRON_DENSITY)
      continue
   case(TEMPERATURE)
      continue
   case(SPECIFIC_HUMIDITY)
      continue
   case(PRESSURE)
      continue
   case(RADIOSONDE_U_WIND_COMPONENT)
      continue
   case(RADIOSONDE_V_WIND_COMPONENT)
      continue
   case(RADIOSONDE_GEOPOTENTIAL_HGT)
      continue
   case(RADIOSONDE_SURFACE_PRESSURE)
      continue
   case(RADIOSONDE_TEMPERATURE)
      continue
   case(RADIOSONDE_SPECIFIC_HUMIDITY)
      continue
   case(DROPSONDE_U_WIND_COMPONENT)
      continue
   case(DROPSONDE_V_WIND_COMPONENT)
      continue
   case(DROPSONDE_SURFACE_PRESSURE)
      continue
   case(DROPSONDE_TEMPERATURE)
      continue
   case(DROPSONDE_SPECIFIC_HUMIDITY)
      continue
   case(AIRCRAFT_U_WIND_COMPONENT)
      continue
   case(AIRCRAFT_V_WIND_COMPONENT)
      continue
   case(AIRCRAFT_TEMPERATURE)
      continue
   case(AIRCRAFT_SPECIFIC_HUMIDITY)
      continue
   case(ACARS_U_WIND_COMPONENT)
      continue
   case(ACARS_V_WIND_COMPONENT)
      continue
   case(ACARS_TEMPERATURE)
      continue
   case(ACARS_SPECIFIC_HUMIDITY)
      continue
   case(MARINE_SFC_U_WIND_COMPONENT)
      continue
   case(MARINE_SFC_V_WIND_COMPONENT)
      continue
   case(MARINE_SFC_TEMPERATURE)
      continue
   case(MARINE_SFC_SPECIFIC_HUMIDITY)
      continue
   case(MARINE_SFC_PRESSURE)
      continue
   case(LAND_SFC_U_WIND_COMPONENT)
      continue
   case(LAND_SFC_V_WIND_COMPONENT)
      continue
   case(LAND_SFC_TEMPERATURE)
      continue
   case(LAND_SFC_SPECIFIC_HUMIDITY)
      continue
   case(LAND_SFC_PRESSURE)
      continue
   case(SAT_U_WIND_COMPONENT)
      continue
   case(SAT_V_WIND_COMPONENT)
      continue
   case(ATOV_TEMPERATURE)
      continue
   case(AIRS_TEMPERATURE)
      continue
   case(AIRS_SPECIFIC_HUMIDITY)
      continue
   case(GPS_PRECIPITABLE_WATER)
      continue
   case(SAT_TEMPERATURE)
      continue
   case(SAT_TEMPERATURE_ELECTRON)
      continue
   case(SAT_TEMPERATURE_ION)
      continue
   case(SAT_DENSITY_NEUTRAL_O3P)
      continue
   case(SAT_DENSITY_NEUTRAL_O2)
      continue
   case(SAT_DENSITY_NEUTRAL_N2)
      continue
   case(SAT_DENSITY_NEUTRAL_N4S)
      continue
   case(SAT_DENSITY_NEUTRAL_NO)
      continue
   case(SAT_DENSITY_NEUTRAL_N2D)
      continue
   case(SAT_DENSITY_NEUTRAL_N2P)
      continue
   case(SAT_DENSITY_NEUTRAL_H)
      continue
   case(SAT_DENSITY_NEUTRAL_HE)
      continue
   case(SAT_DENSITY_NEUTRAL_CO2)
      continue
   case(SAT_DENSITY_NEUTRAL_O1D)
      continue
   case(SAT_DENSITY_ION_O4SP)
      continue
   case(SAT_DENSITY_ION_O2P)
      continue
   case(SAT_DENSITY_ION_N2P)
      continue
   case(SAT_DENSITY_ION_NP)
      continue
   case(SAT_DENSITY_ION_NOP)
      continue
   case(SAT_DENSITY_ION_O2DP)
      continue
   case(SAT_DENSITY_ION_O2PP)
      continue
   case(SAT_DENSITY_ION_HP)
      continue
   case(SAT_DENSITY_ION_HEP)
      continue
   case(SAT_DENSITY_ION_E)
      continue
   case(SAT_VELOCITY_U)
      continue
   case(SAT_VELOCITY_V)
      continue
   case(SAT_VELOCITY_W)
      continue
   case(SAT_VELOCITY_U_ION)
      continue
   case(SAT_VELOCITY_V_ION)
      continue
   case(SAT_VELOCITY_W_ION)
      continue
   case(SAT_VELOCITY_VERTICAL_O3P)
      continue
   case(SAT_VELOCITY_VERTICAL_O2)
      continue
   case(SAT_VELOCITY_VERTICAL_N2)
      continue
   case(SAT_VELOCITY_VERTICAL_N4S)
      continue
   case(SAT_VELOCITY_VERTICAL_NO)
      continue
   case(SAT_F107)
      continue
   case(GPS_PROFILE)
      continue
   case(GPS_VTEC_EXTRAP)
      continue
   case(SABER_TEMPERATURE)
      continue
   case(AURAMLS_TEMPERATURE)
      continue

! A negative value means identity observations, just move along
   case (:-1)
      continue

   case DEFAULT
      write(errstring, *) 'unknown type number was ', obs_def%kind
      call error_handler(E_ERR, 'read_obs_def', &
         'Attempt to read for undefined obs_kind type.', &
         source, revision, revdate, text2=errstring)
end select

! We need to see whether there is external prior metadata.
! If so, we need to read it in, but that doesn't necessarily mean
! the precomputed FO will acutally be used for that particular obs_type
time_set = .false.
obs_def%write_external_FO = .false.  ! Always false when actually running DART
if (is_ascii) then
   read(ifile,fmt='(a)') string
   if (string(1:11) /= 'external_FO') then
      ! no metadata, we really just read the time.
      backspace(ifile) ! go back to previous line to prepare to read time
      obs_def%has_external_FO = .false.
   else ! we have a precomputed FO
      read(string, *) header_external_FO, obs_def%ens_size, obs_def%external_FO_key
      ! FIXME: remove this if * works ok
      !read(string, FMT='(a11, 2i8)') header_external_FO, obs_def%ens_size, obs_def%external_FO_key
      if ( .not. allocated(obs_def%external_FO)) allocate(obs_def%external_FO(obs_def%ens_size))
      read(ifile, *) (obs_def%external_FO(ii), ii=1,obs_def%ens_size)
      obs_def%has_external_FO = .true.
   endif
else
   read(ifile) secs, days
   if ( days /= external_prior_code ) then
      ! no metadata, we really just read the time
      ! can't use backspace on a binary file.
      obs_def%time = set_time(secs, days)
      time_set = .true.
      obs_def%has_external_FO = .false.
   else ! we have a precomputed FO
      counter = counter + 1
      obs_def%ens_size = secs
      obs_def%external_FO_key = counter
      if ( .not. allocated(obs_def%external_FO)) allocate(obs_def%external_FO(obs_def%ens_size))
      read(ifile)    (obs_def%external_FO(ii), ii=1,obs_def%ens_size)
      obs_def%has_external_FO = .true.
   endif
endif

! Read the time for the observation
if ( .not. time_set ) obs_def%time = read_time(ifile, fform)

if (is_ascii) then
   read(ifile, *) obs_def%error_variance
else
   read(ifile)    obs_def%error_variance
endif

end subroutine read_obs_def

!----------------------------------------------------------------------------

subroutine write_obs_def(ifile, obs_def, key, fform)

! Writes an obs_def to file.

integer,                    intent(in) :: ifile
type(obs_def_type),         intent(in) :: obs_def
integer,                    intent(in) :: key
character(len=*), intent(in), optional :: fform

logical           :: is_ascii
character(len=32) :: fileformat   ! here for backwards compatibility only

integer            :: ii ! CSS

if ( .not. module_initialized ) call initialize_module

is_ascii = ascii_file_format(fform)

! here for backwards compatibility only; after the next release,
! remove this and force people in their own obs_def_xxx_mod.f90 code
! to set the last arg to read/write to be fform instead of fileformat
if (is_ascii) then
   fileformat = 'formatted'
else
   fileformat = 'unformatted'
endif

! Write the 5 character identifier for verbose formatted output
if (is_ascii) write(ifile, '("obdef")')

! Write out the location, kind and error variance
call write_location(ifile, obs_def%location, fform)
if (is_ascii) then
   write(ifile, '("kind")' )
   write(ifile, *) obs_def%kind
else
   write(ifile)    obs_def%kind
endif

! This kind may have its own module that needs to write more
select case(obs_def%kind)
   ! More complicated kinds may require writing additional information from
   ! an observation sequence file. Case code to do this is inserted here by
   ! the DART preprocess program.

         case(GPSRO_REFRACTIVITY)
            call write_gpsro_ref(obs_def%key, ifile, fform)
         case(RADIOSONDE_SURFACE_ALTIMETER, DROPSONDE_SURFACE_ALTIMETER, MARINE_SFC_ALTIMETER, &
              LAND_SFC_ALTIMETER, METAR_ALTIMETER)
            continue
 case(SAT_RHO)
      continue
 case(CHAMP_DENSITY)
      continue
 case(MIDAS_TEC)
      continue
 case(GND_GPS_VTEC)
      continue
 case(SSUSI_O_N2_RATIO)
      continue
 case(COSMIC_ELECTRON_DENSITY)
      continue
   case(TEMPERATURE)
      continue
   case(SPECIFIC_HUMIDITY)
      continue
   case(PRESSURE)
      continue
   case(RADIOSONDE_U_WIND_COMPONENT)
      continue
   case(RADIOSONDE_V_WIND_COMPONENT)
      continue
   case(RADIOSONDE_GEOPOTENTIAL_HGT)
      continue
   case(RADIOSONDE_SURFACE_PRESSURE)
      continue
   case(RADIOSONDE_TEMPERATURE)
      continue
   case(RADIOSONDE_SPECIFIC_HUMIDITY)
      continue
   case(DROPSONDE_U_WIND_COMPONENT)
      continue
   case(DROPSONDE_V_WIND_COMPONENT)
      continue
   case(DROPSONDE_SURFACE_PRESSURE)
      continue
   case(DROPSONDE_TEMPERATURE)
      continue
   case(DROPSONDE_SPECIFIC_HUMIDITY)
      continue
   case(AIRCRAFT_U_WIND_COMPONENT)
      continue
   case(AIRCRAFT_V_WIND_COMPONENT)
      continue
   case(AIRCRAFT_TEMPERATURE)
      continue
   case(AIRCRAFT_SPECIFIC_HUMIDITY)
      continue
   case(ACARS_U_WIND_COMPONENT)
      continue
   case(ACARS_V_WIND_COMPONENT)
      continue
   case(ACARS_TEMPERATURE)
      continue
   case(ACARS_SPECIFIC_HUMIDITY)
      continue
   case(MARINE_SFC_U_WIND_COMPONENT)
      continue
   case(MARINE_SFC_V_WIND_COMPONENT)
      continue
   case(MARINE_SFC_TEMPERATURE)
      continue
   case(MARINE_SFC_SPECIFIC_HUMIDITY)
      continue
   case(MARINE_SFC_PRESSURE)
      continue
   case(LAND_SFC_U_WIND_COMPONENT)
      continue
   case(LAND_SFC_V_WIND_COMPONENT)
      continue
   case(LAND_SFC_TEMPERATURE)
      continue
   case(LAND_SFC_SPECIFIC_HUMIDITY)
      continue
   case(LAND_SFC_PRESSURE)
      continue
   case(SAT_U_WIND_COMPONENT)
      continue
   case(SAT_V_WIND_COMPONENT)
      continue
   case(ATOV_TEMPERATURE)
      continue
   case(AIRS_TEMPERATURE)
      continue
   case(AIRS_SPECIFIC_HUMIDITY)
      continue
   case(GPS_PRECIPITABLE_WATER)
      continue
   case(SAT_TEMPERATURE)
      continue
   case(SAT_TEMPERATURE_ELECTRON)
      continue
   case(SAT_TEMPERATURE_ION)
      continue
   case(SAT_DENSITY_NEUTRAL_O3P)
      continue
   case(SAT_DENSITY_NEUTRAL_O2)
      continue
   case(SAT_DENSITY_NEUTRAL_N2)
      continue
   case(SAT_DENSITY_NEUTRAL_N4S)
      continue
   case(SAT_DENSITY_NEUTRAL_NO)
      continue
   case(SAT_DENSITY_NEUTRAL_N2D)
      continue
   case(SAT_DENSITY_NEUTRAL_N2P)
      continue
   case(SAT_DENSITY_NEUTRAL_H)
      continue
   case(SAT_DENSITY_NEUTRAL_HE)
      continue
   case(SAT_DENSITY_NEUTRAL_CO2)
      continue
   case(SAT_DENSITY_NEUTRAL_O1D)
      continue
   case(SAT_DENSITY_ION_O4SP)
      continue
   case(SAT_DENSITY_ION_O2P)
      continue
   case(SAT_DENSITY_ION_N2P)
      continue
   case(SAT_DENSITY_ION_NP)
      continue
   case(SAT_DENSITY_ION_NOP)
      continue
   case(SAT_DENSITY_ION_O2DP)
      continue
   case(SAT_DENSITY_ION_O2PP)
      continue
   case(SAT_DENSITY_ION_HP)
      continue
   case(SAT_DENSITY_ION_HEP)
      continue
   case(SAT_DENSITY_ION_E)
      continue
   case(SAT_VELOCITY_U)
      continue
   case(SAT_VELOCITY_V)
      continue
   case(SAT_VELOCITY_W)
      continue
   case(SAT_VELOCITY_U_ION)
      continue
   case(SAT_VELOCITY_V_ION)
      continue
   case(SAT_VELOCITY_W_ION)
      continue
   case(SAT_VELOCITY_VERTICAL_O3P)
      continue
   case(SAT_VELOCITY_VERTICAL_O2)
      continue
   case(SAT_VELOCITY_VERTICAL_N2)
      continue
   case(SAT_VELOCITY_VERTICAL_N4S)
      continue
   case(SAT_VELOCITY_VERTICAL_NO)
      continue
   case(SAT_F107)
      continue
   case(GPS_PROFILE)
      continue
   case(GPS_VTEC_EXTRAP)
      continue
   case(SABER_TEMPERATURE)
      continue
   case(AURAMLS_TEMPERATURE)
      continue

   ! A negative value means identity observations, just move along
   case (:-1)
      continue

   case DEFAULT
      call error_handler(E_ERR, 'write_obs_def', &
         'Attempt to write for undefined obs_kind type.', &
         source, revision, revdate)
end select

! obs_def%write_external_FO should only be true for program
! actually WRITING the external data.  When running DART
! obs_def%write_external_FO should be false and no metadata will be written
! Also want obs_def%write_external_FO to somehow be true when this called from
! the obs_sequence_tool program
if ( obs_def%has_external_FO .and. obs_def%write_external_FO ) then
   if ( .not. allocated(obs_def%external_FO)) then
      call error_handler(E_ERR, 'write_obs_def', &
         'obs_def%external_FO not allocated but writing was requested.', &
         source, revision, revdate, text2='observation type '//trim(get_name_for_type_of_obs(obs_def%kind)))
   endif
   if (is_ascii) then
      write(ifile, 12) obs_def%ens_size, obs_def%external_FO_key
      write(ifile, *) (obs_def%external_FO(ii), ii=1,obs_def%ens_size)
   else
      write(ifile)    obs_def%ens_size, external_prior_code
      write(ifile)    (obs_def%external_FO(ii), ii=1,obs_def%ens_size)
   endif
12  format('external_FO', 2i8)
endif

call write_time(ifile, obs_def%time, fform)

if (is_ascii) then
   write(ifile, *) obs_def%error_variance
else
   write(ifile)    obs_def%error_variance
endif

end subroutine write_obs_def


subroutine interactive_obs_def(obs_def, key)
!---------------------------------------------------------------------------
!
! Allows interactive creation of an observation

type(obs_def_type), intent(inout) :: obs_def
integer,               intent(in) :: key

if ( .not. module_initialized ) call initialize_module

! Get the observation kind WANT A STRING OPTION, TOO?
obs_def%kind = get_type_of_obs_from_menu()

! Input any special stuff for this kind
select case(obs_def%kind)
   ! More complicated kinds may require inputting additional information to
   ! define an observation. Case code to do this is inserted here by the
   ! DART preprocess program.

         case(GPSRO_REFRACTIVITY)
            call interactive_gpsro_ref(obs_def%key)
         case(RADIOSONDE_SURFACE_ALTIMETER, DROPSONDE_SURFACE_ALTIMETER, MARINE_SFC_ALTIMETER, &
              LAND_SFC_ALTIMETER, METAR_ALTIMETER)
            continue
 case(SAT_RHO)
      continue
 case(CHAMP_DENSITY)
      continue
 case(MIDAS_TEC)
      continue
 case(GND_GPS_VTEC)
      continue
 case(SSUSI_O_N2_RATIO)
      continue
 case(COSMIC_ELECTRON_DENSITY)
      continue
   case(TEMPERATURE)
      continue
   case(SPECIFIC_HUMIDITY)
      continue
   case(PRESSURE)
      continue
   case(RADIOSONDE_U_WIND_COMPONENT)
      continue
   case(RADIOSONDE_V_WIND_COMPONENT)
      continue
   case(RADIOSONDE_GEOPOTENTIAL_HGT)
      continue
   case(RADIOSONDE_SURFACE_PRESSURE)
      continue
   case(RADIOSONDE_TEMPERATURE)
      continue
   case(RADIOSONDE_SPECIFIC_HUMIDITY)
      continue
   case(DROPSONDE_U_WIND_COMPONENT)
      continue
   case(DROPSONDE_V_WIND_COMPONENT)
      continue
   case(DROPSONDE_SURFACE_PRESSURE)
      continue
   case(DROPSONDE_TEMPERATURE)
      continue
   case(DROPSONDE_SPECIFIC_HUMIDITY)
      continue
   case(AIRCRAFT_U_WIND_COMPONENT)
      continue
   case(AIRCRAFT_V_WIND_COMPONENT)
      continue
   case(AIRCRAFT_TEMPERATURE)
      continue
   case(AIRCRAFT_SPECIFIC_HUMIDITY)
      continue
   case(ACARS_U_WIND_COMPONENT)
      continue
   case(ACARS_V_WIND_COMPONENT)
      continue
   case(ACARS_TEMPERATURE)
      continue
   case(ACARS_SPECIFIC_HUMIDITY)
      continue
   case(MARINE_SFC_U_WIND_COMPONENT)
      continue
   case(MARINE_SFC_V_WIND_COMPONENT)
      continue
   case(MARINE_SFC_TEMPERATURE)
      continue
   case(MARINE_SFC_SPECIFIC_HUMIDITY)
      continue
   case(MARINE_SFC_PRESSURE)
      continue
   case(LAND_SFC_U_WIND_COMPONENT)
      continue
   case(LAND_SFC_V_WIND_COMPONENT)
      continue
   case(LAND_SFC_TEMPERATURE)
      continue
   case(LAND_SFC_SPECIFIC_HUMIDITY)
      continue
   case(LAND_SFC_PRESSURE)
      continue
   case(SAT_U_WIND_COMPONENT)
      continue
   case(SAT_V_WIND_COMPONENT)
      continue
   case(ATOV_TEMPERATURE)
      continue
   case(AIRS_TEMPERATURE)
      continue
   case(AIRS_SPECIFIC_HUMIDITY)
      continue
   case(GPS_PRECIPITABLE_WATER)
      continue
   case(SAT_TEMPERATURE)
      continue
   case(SAT_TEMPERATURE_ELECTRON)
      continue
   case(SAT_TEMPERATURE_ION)
      continue
   case(SAT_DENSITY_NEUTRAL_O3P)
      continue
   case(SAT_DENSITY_NEUTRAL_O2)
      continue
   case(SAT_DENSITY_NEUTRAL_N2)
      continue
   case(SAT_DENSITY_NEUTRAL_N4S)
      continue
   case(SAT_DENSITY_NEUTRAL_NO)
      continue
   case(SAT_DENSITY_NEUTRAL_N2D)
      continue
   case(SAT_DENSITY_NEUTRAL_N2P)
      continue
   case(SAT_DENSITY_NEUTRAL_H)
      continue
   case(SAT_DENSITY_NEUTRAL_HE)
      continue
   case(SAT_DENSITY_NEUTRAL_CO2)
      continue
   case(SAT_DENSITY_NEUTRAL_O1D)
      continue
   case(SAT_DENSITY_ION_O4SP)
      continue
   case(SAT_DENSITY_ION_O2P)
      continue
   case(SAT_DENSITY_ION_N2P)
      continue
   case(SAT_DENSITY_ION_NP)
      continue
   case(SAT_DENSITY_ION_NOP)
      continue
   case(SAT_DENSITY_ION_O2DP)
      continue
   case(SAT_DENSITY_ION_O2PP)
      continue
   case(SAT_DENSITY_ION_HP)
      continue
   case(SAT_DENSITY_ION_HEP)
      continue
   case(SAT_DENSITY_ION_E)
      continue
   case(SAT_VELOCITY_U)
      continue
   case(SAT_VELOCITY_V)
      continue
   case(SAT_VELOCITY_W)
      continue
   case(SAT_VELOCITY_U_ION)
      continue
   case(SAT_VELOCITY_V_ION)
      continue
   case(SAT_VELOCITY_W_ION)
      continue
   case(SAT_VELOCITY_VERTICAL_O3P)
      continue
   case(SAT_VELOCITY_VERTICAL_O2)
      continue
   case(SAT_VELOCITY_VERTICAL_N2)
      continue
   case(SAT_VELOCITY_VERTICAL_N4S)
      continue
   case(SAT_VELOCITY_VERTICAL_NO)
      continue
   case(SAT_F107)
      continue
   case(GPS_PROFILE)
      continue
   case(GPS_VTEC_EXTRAP)
      continue
   case(SABER_TEMPERATURE)
      continue
   case(AURAMLS_TEMPERATURE)
      continue

   ! A negative value means identity observations, just move along
   case (:-1)
      continue
   case DEFAULT
      call error_handler(E_ERR, 'interactive_obs_def', &
         'Attempt to interactively create undefined obs_kind type.', &
         source, revision, revdate)
end select

! If the kind is an identity observation, don't need to call location
! Get location from state meta_data
if(obs_def%kind < 0) then
   ! Get the location of this from model
   call get_state_meta_data(-1_i8 * obs_def%kind, obs_def%location)
else! Get the location
   call interactive_location(obs_def%location)
endif

! Get the time
call interactive_time(obs_def%time)

write(*, *) 'Input the error variance for this observation definition '
read(*, *) obs_def%error_variance
do while (obs_def%error_variance < 0)
   write(*, *) 'The error variance must be positive, please try again'
   read(*, *) obs_def%error_variance
enddo

end subroutine interactive_obs_def

!----------------------------------------------------------------

subroutine destroy_obs_def(obs_def)
! TECHNICALLY NEED TO CALL DESTRUCTORS FOR ALL SUBCOMPONENTS,
! NO ALLOCATED STORAGE YET

type(obs_def_type), intent(inout) :: obs_def

if ( .not. module_initialized ) call initialize_module

! FIXME: not clear why we have to set all these to missing...
! we definitely have to do the deallocate but the others seem
! like unnecessary work.

call set_obs_def_location(obs_def, set_location_missing() )
obs_def%kind = missing_i
call set_obs_def_time(obs_def, set_time_missing() )
call set_obs_def_error_variance( obs_def, missing_r8)
call set_obs_def_external_FO(obs_def, .false., .false., missing_i, 1, (/missing_r8/))
if ( allocated(obs_def%external_FO)) deallocate(obs_def%external_FO) ! CSS

end subroutine destroy_obs_def



!---------------------------------------------------------------------------
!---------------------------------------------------------------------------

end module obs_def_mod

! <next few lines under version control, do not edit>
! $URL$
! $Id$
! $Revision$
! $Date$
